<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [OpenIMSCore-CSCF] [SVN-ser_ims] r128 - in	ser_ims/branches/01_persistency: cfg modules/isc	modules/pcscf modules/scscf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openimscore-cscf/2007-February/index.html" >
   <LINK REL="made" HREF="mailto:openimscore-cscf%40lists.berlios.de?Subject=Re%3A%20%5BOpenIMSCore-CSCF%5D%20%5BSVN-ser_ims%5D%20r128%20-%20in%0A%09ser_ims/branches/01_persistency%3A%20cfg%20modules/isc%0A%09modules/pcscf%20modules/scscf&In-Reply-To=%3C200702080015.l180F2L9029537%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000203.html">
   <LINK REL="Next"  HREF="000193.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[OpenIMSCore-CSCF] [SVN-ser_ims] r128 - in	ser_ims/branches/01_persistency: cfg modules/isc	modules/pcscf modules/scscf</H1>
    <B>vingarzan at users.berlios.de</B> 
    <A HREF="mailto:openimscore-cscf%40lists.berlios.de?Subject=Re%3A%20%5BOpenIMSCore-CSCF%5D%20%5BSVN-ser_ims%5D%20r128%20-%20in%0A%09ser_ims/branches/01_persistency%3A%20cfg%20modules/isc%0A%09modules/pcscf%20modules/scscf&In-Reply-To=%3C200702080015.l180F2L9029537%40sheep.berlios.de%3E"
       TITLE="[OpenIMSCore-CSCF] [SVN-ser_ims] r128 - in	ser_ims/branches/01_persistency: cfg modules/isc	modules/pcscf modules/scscf">vingarzan at users.berlios.de
       </A><BR>
    <I>Thu Feb  8 01:15:02 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000203.html">[OpenIMSCore-CSCF] changes to mysql when 127.0.0.1 is changed	to local IP
</A></li>
        <LI>Next message: <A HREF="000193.html">[OpenIMSCore-CSCF] [SVN-ser_ims] r129 - in	ser_ims/branches/01_persistency/modules: pcscf scscf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#191">[ date ]</a>
              <a href="thread.html#191">[ thread ]</a>
              <a href="subject.html#191">[ subject ]</a>
              <a href="author.html#191">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: vingarzan
Date: 2007-02-08 01:14:53 +0100 (Thu, 08 Feb 2007)
New Revision: 128

Modified:
   ser_ims/branches/01_persistency/cfg/pcscf.cfg
   ser_ims/branches/01_persistency/modules/isc/checker.c
   ser_ims/branches/01_persistency/modules/isc/checker.h
   ser_ims/branches/01_persistency/modules/isc/mark.h
   ser_ims/branches/01_persistency/modules/pcscf/bin_pcscf.c
   ser_ims/branches/01_persistency/modules/pcscf/bin_pcscf.h
   ser_ims/branches/01_persistency/modules/pcscf/dlg_state.h
   ser_ims/branches/01_persistency/modules/pcscf/mod.c
   ser_ims/branches/01_persistency/modules/pcscf/p_persistency.c
   ser_ims/branches/01_persistency/modules/pcscf/p_persistency.h
   ser_ims/branches/01_persistency/modules/pcscf/registrar_storage.h
   ser_ims/branches/01_persistency/modules/pcscf/registrar_subscribe.c
   ser_ims/branches/01_persistency/modules/pcscf/registrar_subscribe.h
   ser_ims/branches/01_persistency/modules/scscf/bin.c
   ser_ims/branches/01_persistency/modules/scscf/bin.h
   ser_ims/branches/01_persistency/modules/scscf/bin_scscf.c
   ser_ims/branches/01_persistency/modules/scscf/bin_scscf.h
   ser_ims/branches/01_persistency/modules/scscf/ifc_datastruct.h
   ser_ims/branches/01_persistency/modules/scscf/registrar_parser.c
   ser_ims/branches/01_persistency/modules/scscf/registrar_storage.h
   ser_ims/branches/01_persistency/modules/scscf/registration.c
   ser_ims/branches/01_persistency/modules/scscf/registration.h
Log:
Fixed the bin codec:
	- the int1/int2/int4 functions were removed because they were prone to errors.
	- new functions for char,uchar,short,ushort,int,uint,time_t were introduced

Because of the bin codec fix many data structures were changed and also optimized for space.
Lots of changes in the code due to changes in the data structures.

Introduced persistency for P-CSCF subscriptions to reg.



Modified: ser_ims/branches/01_persistency/cfg/pcscf.cfg
===================================================================
--- ser_ims/branches/01_persistency/cfg/pcscf.cfg	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/cfg/pcscf.cfg	2007-02-08 00:14:53 UTC (rev 128)
@@ -82,6 +82,7 @@
 modparam(&quot;pcscf&quot;,&quot;persistency_location&quot;,&quot;/opt/OpenIMSCore/persistency&quot;)
 modparam(&quot;pcscf&quot;,&quot;persistency_timer_dialogs&quot;,60)
 modparam(&quot;pcscf&quot;,&quot;persistency_timer_registrar&quot;,60)
+modparam(&quot;pcscf&quot;,&quot;persistency_timer_subscriptions&quot;,60)
 
 # -- rr params --
 # add value to ;lr param to make some broken UAs happy

Modified: ser_ims/branches/01_persistency/modules/isc/checker.c
===================================================================
--- ser_ims/branches/01_persistency/modules/isc/checker.c	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/isc/checker.c	2007-02-08 00:14:53 UTC (rev 128)
@@ -190,7 +190,7 @@
  *	@param registration_type - if the message is initial/re/de registration
  *	@returns - 1 on success, 0 on failure
  */
-static int isc_check_spt(ims_spt *spt,struct sip_msg *msg,int direction,int registration_type)
+static int isc_check_spt(ims_spt *spt,struct sip_msg *msg,char direction,char registration_type)
 {
 	int r=FALSE;
 	switch(spt-&gt;type){
@@ -255,8 +255,8 @@
  *	@param registration_type - if the message is initial/re/de registration
  *	@returns - 1 on success, 0 on failure
  */
-static int isc_check_filter_criteria(ims_filter_criteria *fc,struct sip_msg *msg,int direction,
-		int registration_type)
+static int isc_check_filter_criteria(ims_filter_criteria *fc,struct sip_msg *msg,char direction,
+		char registration_type)
 {
 	int i,partial,total,inside,outside,group;
 	ims_trigger_point *t;
@@ -374,9 +374,10 @@
  * @param msg - the SIP initial request to check on 
  * @return - TRUE if found, FALSE if none found, end of search space 
  */
-isc_match* isc_checker_find(str uri,int direction,int skip,struct sip_msg *msg)
+isc_match* isc_checker_find(str uri,char direction,int skip,struct sip_msg *msg)
 {
-	int registered,expires,registration_type;
+	int registered,expires;
+	char registration_type;
 	str domain={0,0};
 	int i,j,k,cnt,si,sj,next;
 	r_public *p;

Modified: ser_ims/branches/01_persistency/modules/isc/checker.h
===================================================================
--- ser_ims/branches/01_persistency/modules/isc/checker.h	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/isc/checker.h	2007-02-08 00:14:53 UTC (rev 128)
@@ -68,7 +68,7 @@
 /** ISC match structure */
 typedef struct {
 	str server_name;		/**&lt; SIP URI of the AS to forward to */
-	int default_handling;	/**&lt; handling to apply on failure to contact the AS */
+	char default_handling;	/**&lt; handling to apply on failure to contact the AS */
 	str service_info;		/**&lt; additional service information */
 	int index;				/**&lt; index of the matching IFC */
 } isc_match;
@@ -76,7 +76,7 @@
 
 void isc_free_match(isc_match *m);
 
-isc_match* isc_checker_find(str uri,int direction,int skip,struct sip_msg *msg);
+isc_match* isc_checker_find(str uri,char direction,int skip,struct sip_msg *msg);
 
 
 

Modified: ser_ims/branches/01_persistency/modules/isc/mark.h
===================================================================
--- ser_ims/branches/01_persistency/modules/isc/mark.h	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/isc/mark.h	2007-02-08 00:14:53 UTC (rev 128)
@@ -78,8 +78,8 @@
 /** ISC marking structure */
 typedef struct _isc_mark{
 	int skip;		/**&lt; how many IFCs to skip */
-	int handling;	/**&lt; handling to apply on failure to contact the AS */
-	int direction;	/**&lt; session case: orig,term,term unreg */
+	char handling;	/**&lt; handling to apply on failure to contact the AS */
+	char direction;	/**&lt; session case: orig,term,term unreg */
 } isc_mark;
 
 

Modified: ser_ims/branches/01_persistency/modules/pcscf/bin_pcscf.c
===================================================================
--- ser_ims/branches/01_persistency/modules/pcscf/bin_pcscf.c	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/pcscf/bin_pcscf.c	2007-02-08 00:14:53 UTC (rev 128)
@@ -54,8 +54,9 @@
 
 #include &quot;bin_pcscf.h&quot;
 
-/* structures reprezentation functions */
 
+extern struct tm_binds tmb;   		/**&lt; Structure with pointers to tm funcs 		*/
+
 extern int r_hash_size;						/**&lt; Size of S-CSCF registrar hash table		*/
 
 
@@ -81,30 +82,32 @@
  */
 int bin_encode_p_dialog(bin_data *x,p_dialog *d)
 {
-	int i,k;
+	int i;
+	char c;
 	
 	if (!bin_encode_str(x,&amp;(d-&gt;call_id))) goto error;
 	
 	if (!bin_encode_str(x,&amp;(d-&gt;host))) goto error;
-	k = d-&gt;port;
-	if (!bin_encode_int2(x,k)) goto error;
-	k = d-&gt;transport;
-	if (!bin_encode_int1(x,k)) goto error;
+	if (!bin_encode_ushort(x,d-&gt;port)) goto error;
+	
+	c = d-&gt;transport;
+	if (!bin_encode_uchar(x,c)) goto error;
 
-	if (!bin_encode_int2(x,d-&gt;routes_cnt)) goto error;
+	if (!bin_encode_ushort(x,d-&gt;routes_cnt)) goto error;
 	for(i=0;i&lt;d-&gt;routes_cnt;i++)
 		if (!bin_encode_str(x,d-&gt;routes+i)) goto error;
-
-	k = d-&gt;method;
-	if (!bin_encode_int1(x,k)) goto error;
+	
+	c = d-&gt;method;
+	if (!bin_encode_uchar(x,c)) goto error;
 	if (!bin_encode_str(x,&amp;(d-&gt;method_str))) goto error;
 	
-	if (!bin_encode_int4(x,d-&gt;first_cseq)) goto error;	
-	if (!bin_encode_int4(x,d-&gt;last_cseq)) goto error;	
+	if (!bin_encode_int(x,d-&gt;first_cseq)) goto error;	
+	if (!bin_encode_int(x,d-&gt;last_cseq)) goto error;	
 
-	if (!bin_encode_int1(x,d-&gt;state)) goto error;	
+	c = d-&gt;state;
+	if (!bin_encode_uchar(x,c)) goto error;	
 
-	if (!bin_encode_int4(x,d-&gt;expires)) goto error;		
+	if (!bin_encode_time_t(x,d-&gt;expires)) goto error;		
 	
 	return 1;
 error:
@@ -120,8 +123,9 @@
 p_dialog* bin_decode_p_dialog(bin_data *x)
 {
 	p_dialog *d=0;
-	int len,k,i;
+	int len,i;
 	str s;
+	char c;
 	
 	len = sizeof(p_dialog);
 	d = (p_dialog*) shm_malloc(len);
@@ -134,13 +138,12 @@
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(d-&gt;call_id),&amp;s)) goto error;
 
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(d-&gt;host),&amp;s)) goto error;
-	if (!bin_decode_int2(x,	&amp;k)) goto error;
-	d-&gt;port = k;
-	if (!bin_decode_int1(x,	&amp;k)) goto error;
-	d-&gt;transport = k;
+	if (!bin_decode_ushort(x,	&amp;d-&gt;port)) goto error;
+	
+	if (!bin_decode_char(x,	&amp;c)) goto error;
+	d-&gt;transport = c;
 
-	if (!bin_decode_int2(x,	&amp;k)) goto error;
-	d-&gt;routes_cnt = k;
+	if (!bin_decode_ushort(x,	&amp;d-&gt;routes_cnt)) goto error;
 
 	len = sizeof(str)*d-&gt;routes_cnt;
 	d-&gt;routes = (str*) shm_malloc(len);
@@ -152,20 +155,17 @@
 	for(i=0;i&lt;d-&gt;routes_cnt;i++)
 		if (!bin_decode_str(x,&amp;s)||!str_shm_dup(d-&gt;routes+i,&amp;s)) goto error;
 	
-	if (!bin_decode_int1(x,	&amp;k)) goto error;
-	d-&gt;method = k;
+	if (!bin_decode_char(x,	&amp;c)) goto error;
+	d-&gt;method = c;
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(d-&gt;method_str),&amp;s)) goto error;
 	
-	if (!bin_decode_int4(x,	&amp;k)) goto error;
-	d-&gt;first_cseq = k;
-	if (!bin_decode_int4(x,	&amp;k)) goto error;
-	d-&gt;last_cseq = k;
+	if (!bin_decode_int(x,	&amp;d-&gt;first_cseq)) goto error;
+	if (!bin_decode_int(x,	&amp;d-&gt;last_cseq)) goto error;
 
-	if (!bin_decode_int1(x,	&amp;k)) goto error;
-	d-&gt;state = k;
+	if (!bin_decode_char(x,	&amp;c)) goto error;
+	d-&gt;state = c;
 	
-	if (!bin_decode_int4(x,	&amp;k)) goto error;
-	d-&gt;expires = k;
+	if (!bin_decode_time_t(x,	&amp;d-&gt;expires)) goto error;
 	
 	d-&gt;hash = get_p_dialog_hash(d-&gt;call_id);		
 	
@@ -204,18 +204,18 @@
 int bin_encode_ipsec(bin_data *x,r_ipsec *ipsec)
 {
 	if (!ipsec){
-		if (!bin_encode_int1(x,0)) goto error;
+		if (!bin_encode_char(x,0)) goto error;
 		return 1;
 	}
 	
-	if (!bin_encode_int1(x,1)) goto error;
+	if (!bin_encode_char(x,1)) goto error;
 
-	if (!bin_encode_int4(x,ipsec-&gt;spi_uc)) goto error;
-	if (!bin_encode_int4(x,ipsec-&gt;spi_us)) goto error;
-	if (!bin_encode_int4(x,ipsec-&gt;spi_pc)) goto error;
-	if (!bin_encode_int4(x,ipsec-&gt;spi_ps)) goto error;
-	if (!bin_encode_int2(x,ipsec-&gt;port_uc)) goto error;
-	if (!bin_encode_int2(x,ipsec-&gt;port_us)) goto error;
+	if (!bin_encode_int(x,ipsec-&gt;spi_uc)) goto error;
+	if (!bin_encode_int(x,ipsec-&gt;spi_us)) goto error;
+	if (!bin_encode_int(x,ipsec-&gt;spi_pc)) goto error;
+	if (!bin_encode_int(x,ipsec-&gt;spi_ps)) goto error;
+	if (!bin_encode_ushort(x,ipsec-&gt;port_uc)) goto error;
+	if (!bin_encode_ushort(x,ipsec-&gt;port_us)) goto error;
 	
 	if (!bin_encode_str(x,&amp;(ipsec-&gt;ealg))) goto error;
 	if (!bin_encode_str(x,&amp;(ipsec-&gt;ck))) goto error;
@@ -236,12 +236,13 @@
  */
 int bin_decode_ipsec(bin_data *x,r_ipsec **ipsec)
 {
-	int len,k;
+	int len;
 	str s;
+	char c;
 
-	if (!bin_decode_int1(x,	&amp;k)) goto error;
+	if (!bin_decode_char(x,	&amp;c)) goto error;
 	
-	if (k==0) {
+	if (c==0) {
 		*ipsec = 0;
 		return 1;
 	}
@@ -254,18 +255,12 @@
 	}
 	memset(*ipsec,0,len);
 
-	if (!bin_decode_int4(x,	&amp;k)) goto error;
-	(*ipsec)-&gt;spi_uc = k;
-	if (!bin_decode_int4(x,	&amp;k)) goto error;
-	(*ipsec)-&gt;spi_us = k;
-	if (!bin_decode_int4(x,	&amp;k)) goto error;
-	(*ipsec)-&gt;spi_pc = k;
-	if (!bin_decode_int4(x,	&amp;k)) goto error;
-	(*ipsec)-&gt;spi_ps = k;
-	if (!bin_decode_int2(x,	&amp;k)) goto error;
-	(*ipsec)-&gt;port_uc = k;
-	if (!bin_decode_int2(x,	&amp;k)) goto error;
-	(*ipsec)-&gt;port_us = k;
+	if (!bin_decode_int(x,	&amp;(*ipsec)-&gt;spi_uc)) goto error;
+	if (!bin_decode_int(x,	&amp;(*ipsec)-&gt;spi_us)) goto error;
+	if (!bin_decode_int(x,	&amp;(*ipsec)-&gt;spi_pc)) goto error;
+	if (!bin_decode_int(x,	&amp;(*ipsec)-&gt;spi_ps)) goto error;
+	if (!bin_decode_ushort(x,	&amp;(*ipsec)-&gt;port_uc)) goto error;
+	if (!bin_decode_ushort(x,	&amp;(*ipsec)-&gt;port_us)) goto error;
 
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;((*ipsec)-&gt;ealg),&amp;s)) goto error;
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;((*ipsec)-&gt;ck),&amp;s)) goto error;
@@ -297,20 +292,20 @@
 int bin_encode_pinhole(bin_data *x,r_nat_dest *pinhole)
 {
 	if (!pinhole){
-		if (!bin_encode_int1(x,0)) goto error;
+		if (!bin_encode_char(x,0)) goto error;
 		return 1;
 	}
 	
-	if (!bin_encode_int1(x,1)) goto error;
+	if (!bin_encode_char(x,1)) goto error;
 
-	if (!bin_encode_int4(x,pinhole-&gt;nat_addr.af)) goto error;
-	if (!bin_encode_int1(x,pinhole-&gt;nat_addr.len)) goto error;
-	if (!bin_encode_int4(x,pinhole-&gt;nat_addr.u.addr32[0])) goto error;
-	if (!bin_encode_int4(x,pinhole-&gt;nat_addr.u.addr32[1])) goto error;
-	if (!bin_encode_int4(x,pinhole-&gt;nat_addr.u.addr32[2])) goto error;
-	if (!bin_encode_int4(x,pinhole-&gt;nat_addr.u.addr32[3])) goto error;
+	if (!bin_encode_uint(x,pinhole-&gt;nat_addr.af)) goto error;
+	if (!bin_encode_uint(x,pinhole-&gt;nat_addr.len)) goto error;
+	if (!bin_encode_uint(x,pinhole-&gt;nat_addr.u.addr32[0])) goto error;
+	if (!bin_encode_uint(x,pinhole-&gt;nat_addr.u.addr32[1])) goto error;
+	if (!bin_encode_uint(x,pinhole-&gt;nat_addr.u.addr32[2])) goto error;
+	if (!bin_encode_uint(x,pinhole-&gt;nat_addr.u.addr32[3])) goto error;
 	
-	if (!bin_encode_int1(x,pinhole-&gt;nat_port)) goto error;
+	if (!bin_encode_ushort(x,pinhole-&gt;nat_port)) goto error;
 	
 	return 1;
 error:
@@ -326,11 +321,12 @@
  */
 int bin_decode_pinhole(bin_data *x,r_nat_dest **pinhole)
 {
-	int len,k;
+	int len;
+	char c;
 	
-	if (!bin_decode_int1(x,	&amp;k)) goto error;
+	if (!bin_decode_char(x,	&amp;c)) goto error;
 	
-	if (k==0) {
+	if (c==0) {
 		*pinhole = 0;
 		return 1;
 	}
@@ -343,19 +339,13 @@
 	}
 	memset(*pinhole,0,len);
 
-	if (!bin_decode_int4(x,	&amp;k)) goto error;
-	(*pinhole)-&gt;nat_addr.af = k;
-	if (!bin_decode_int1(x,	&amp;k)) goto error;
-	(*pinhole)-&gt;nat_addr.len = k;
-	if (!bin_decode_int4(x,	&amp;k)) goto error;
-	(*pinhole)-&gt;nat_addr.u.addr32[0] = k;
-	if (!bin_decode_int4(x,	&amp;k)) goto error;
-	(*pinhole)-&gt;nat_addr.u.addr32[1] = k;
-	if (!bin_decode_int4(x,	&amp;k)) goto error;
-	(*pinhole)-&gt;nat_addr.u.addr32[2] = k;
-	if (!bin_decode_int4(x,	&amp;k)) goto error;
-	(*pinhole)-&gt;nat_addr.u.addr32[3] = k;
-	
+	if (!bin_decode_uint(x,	&amp;(*pinhole)-&gt;nat_addr.af)) goto error;
+	if (!bin_decode_uint(x,	&amp;(*pinhole)-&gt;nat_addr.len)) goto error;
+	if (!bin_decode_uint(x,	&amp;(*pinhole)-&gt;nat_addr.u.addr32[0])) goto error;
+	if (!bin_decode_uint(x,	&amp;(*pinhole)-&gt;nat_addr.u.addr32[1])) goto error;
+	if (!bin_decode_uint(x,	&amp;(*pinhole)-&gt;nat_addr.u.addr32[2])) goto error;
+	if (!bin_decode_uint(x,	&amp;(*pinhole)-&gt;nat_addr.u.addr32[3])) goto error;
+
 	return 1;
 error:
 	LOG(L_ERR,&quot;ERR:&quot;M_NAME&quot;:bin_decode_pinhole: Error while decoding (at %d (%04x)).\n&quot;,x-&gt;max,x-&gt;max);
@@ -376,8 +366,10 @@
  */
 int bin_encode_r_public(bin_data *x,r_public *p)
 {
+	char c;
 	if (!bin_encode_str(x,&amp;(p-&gt;aor))) goto error;
-	if (!bin_encode_int1(x,p-&gt;is_default)) goto error;
+	c = p-&gt;is_default;
+	if (!bin_encode_char(x,c)) goto error;
 	
 	return 1;
 error:
@@ -393,7 +385,8 @@
 r_public* bin_decode_r_public(bin_data *x)
 {
 	str s;
-	int k,len;
+	int len;
+	char c;
 	r_public *p;
 
 	len = sizeof(r_public);
@@ -405,8 +398,8 @@
 	memset(p,0,len);
 	
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(p-&gt;aor),&amp;s)) goto error;
-	if (!bin_decode_int1(x,	&amp;k)) goto error;
-	p-&gt;is_default = k;
+	if (!bin_decode_char(x,	&amp;c)) goto error;
+	p-&gt;is_default = c;
 	
 	return p;
 error:
@@ -436,35 +429,34 @@
  */
 int bin_encode_r_contact(bin_data *x,r_contact *c)
 {
-	int k,i;
+	int i;
+	char k;
+	unsigned short us;
 	r_public *p=0;
 	
 	if (!bin_encode_str(x,&amp;(c-&gt;host))) goto error;
-	k = c-&gt;port;
-	if (!bin_encode_int2(x,k)) goto error;
-	k = c-&gt;transport;
-	if (!bin_encode_int1(x,k)) goto error;
+	if (!bin_encode_ushort(x,c-&gt;port)) goto error;
+	if (!bin_encode_char(x,c-&gt;transport)) goto error;
 	
 	if (!bin_encode_ipsec(x,c-&gt;ipsec)) goto error;
 	
 	if (!bin_encode_str(x,&amp;(c-&gt;uri))) goto error;
 	
-	k = c-&gt;reg_state+5;
-	if (!bin_encode_int1(x,k)) goto error;
+	k = c-&gt;reg_state;
+	if (!bin_encode_char(x,k)) goto error;
 
-	if (!bin_encode_int4(x,c-&gt;expires)) goto error;
-
-	k = c-&gt;service_route_cnt;
-	if (!bin_encode_int2(x,k)) goto error;
+	if (!bin_encode_time_t(x,c-&gt;expires)) goto error;
+	
+	if (!bin_encode_ushort(x,c-&gt;service_route_cnt)) goto error;
 	for(i=0;i&lt;c-&gt;service_route_cnt;i++)
 		if (!bin_encode_str(x,c-&gt;service_route+i)) goto error;
 		
 	if (!bin_encode_pinhole(x,c-&gt;pinhole)) goto error;
 	
-	k=0;
+	us=0;
 	for(p=c-&gt;head;p;p=p-&gt;next)
-		k++;
-	if (!bin_encode_int2(x,k)) goto error;
+		us++;
+	if (!bin_encode_ushort(x,us)) goto error;
 	for(p=c-&gt;head;p;p=p-&gt;next)
 		if (!bin_encode_r_public(x,p)) goto error;	
 	
@@ -483,7 +475,9 @@
 {
 	r_contact *c=0;
 	r_public *p=0,*pn=0;
-	int len,k,i;
+	int len,i;
+	char k;
+	unsigned short us;
 	str st;
 	
 	len = sizeof(r_contact);
@@ -495,10 +489,8 @@
 	memset(c,0,len);
 	
 	if (!bin_decode_str(x,&amp;st)||!str_shm_dup(&amp;(c-&gt;host),&amp;st)) goto error;
-	if (!bin_decode_int2(x,&amp;k)) goto error;
-	c-&gt;port = k;
-	if (!bin_decode_int1(x,&amp;k)) goto error;
-	c-&gt;transport = k;
+	if (!bin_decode_ushort(x,&amp;c-&gt;port)) goto error;
+	if (!bin_decode_char(x,&amp;c-&gt;transport)) goto error;
 
 	c-&gt;hash = get_contact_hash(c-&gt;host,c-&gt;port,c-&gt;transport,r_hash_size);
 	
@@ -506,14 +498,12 @@
 	
 	if (!bin_decode_str(x,&amp;st)||!str_shm_dup(&amp;(c-&gt;uri),&amp;st)) goto error;
 	
-	if (!bin_decode_int1(x,&amp;k)) goto error;
-	c-&gt;reg_state = k-5;
+	if (!bin_decode_char(x,&amp;k)) goto error;
+	c-&gt;reg_state = k;
 
-	if (!bin_decode_int4(x,&amp;k)) goto error;
-	c-&gt;expires = k;
+	if (!bin_decode_time_t(x,&amp;c-&gt;expires)) goto error;
 	
-	if (!bin_decode_int2(x,	&amp;k)) goto error;
-	c-&gt;service_route_cnt = k;
+	if (!bin_decode_ushort(x,	&amp;c-&gt;service_route_cnt)) goto error;
 
 	len = sizeof(str)*c-&gt;service_route_cnt;
 	c-&gt;service_route = (str*) shm_malloc(len);
@@ -527,8 +517,8 @@
 	
 	if (!bin_decode_pinhole(x,&amp;(c-&gt;pinhole ))) goto error;
 		
-	if (!bin_decode_int2(x,&amp;k)) goto error;
-	for(i=0;i&lt;k;i++){
+	if (!bin_decode_ushort(x,&amp;us)) goto error;
+	for(i=0;i&lt;us;i++){
 		p = bin_decode_r_public(x);
 		if (!p) goto error;
 		p-&gt;prev = c-&gt;tail;
@@ -558,134 +548,73 @@
 
 
 
-//
-///**
-// * Encode a r_subscription into a binary form
-// * @param x - binary data to append to
-// * @param p - the r_subscription to encode
-// * @returns 1 on succcess or 0 on error
-// */
-//int bin_encode_r_subscription(bin_data *x,r_subscription *s)
-//{
-//	int k,i;
-//	
-//	if (!bin_encode_str(x,&amp;(c-&gt;host))) goto error;
-//	k = c-&gt;port;
-//	if (!bin_encode_int2(x,k)) goto error;
-//	k = c-&gt;transport;
-//	if (!bin_encode_int1(x,k)) goto error;
-//	
-//	if (!bin_encode_ipsec(x,c-&gt;ipsec)) goto error;
-//	
-//	if (!bin_encode_str(x,&amp;(c-&gt;uri))) goto error;
-//	
-//	k = c-&gt;reg_state+5;
-//	if (!bin_encode_int1(x,k)) goto error;
-//
-//	if (!bin_encode_int4(x,c-&gt;expires)) goto error;
-//
-//	k = c-&gt;service_route_cnt;
-//	if (!bin_encode_int2(x,k)) goto error;
-//	for(i=0;i&lt;c-&gt;service_route_cnt;i++)
-//		if (!bin_encode_str(x,c-&gt;service_route+i)) goto error;
-//		
-//	if (!bin_encode_pinhole(x,c-&gt;pinhole)) goto error;
-//	
-//	k=0;
-//	for(p=c-&gt;head;p;p=p-&gt;next)
-//		k++;
-//	if (!bin_encode_int2(x,k)) goto error;
-//	for(p=c-&gt;head;p;p=p-&gt;next)
-//		if (!bin_encode_r_public(x,p)) goto error;	
-//	
-//	return 1;
-//error:
-//	LOG(L_ERR,&quot;ERR:&quot;M_NAME&quot;:bin_encode_r_subscription: Error while encoding.\n&quot;);
-//	return 0;		
-//}
-//
-///**
-// *	Decode a r_subscription from a binary data structure
-// * @param x - binary data to decode from
-// * @returns the r_subscription* where the data has been decoded
-// */
-//r_subscription* bin_decode_r_subscription(bin_data *x)
-//{
-//	r_subscription *c=0;
-//	r_public *p=0,*pn=0;
-//	int len,k,i;
-//	str st;
-//	
-//	len = sizeof(r_subscription);
-//	c = (r_subscription*) shm_malloc(len);
-//	if (!c) {
-//		LOG(L_ERR,&quot;ERR:&quot;M_NAME&quot;:bin_decode_r_subscription: Error allocating %d bytes.\n&quot;,len);
-//		goto error;
-//	}
-//	memset(c,0,len);
-//	
-//	if (!bin_decode_str(x,&amp;st)||!str_shm_dup(&amp;(c-&gt;host),&amp;st)) goto error;
-//	if (!bin_decode_int2(x,&amp;k)) goto error;
-//	c-&gt;port = k;
-//	if (!bin_decode_int1(x,&amp;k)) goto error;
-//	c-&gt;transport = k;
-//
-//	c-&gt;hash = get_contact_hash(c-&gt;host,c-&gt;port,c-&gt;transport,r_hash_size);
-//	
-//	if (!bin_decode_ipsec(x,&amp;(c-&gt;ipsec ))) goto error;
-//	
-//	if (!bin_decode_str(x,&amp;st)||!str_shm_dup(&amp;(c-&gt;uri),&amp;st)) goto error;
-//	
-//	if (!bin_decode_int1(x,&amp;k)) goto error;
-//	c-&gt;reg_state = k-5;
-//
-//	if (!bin_decode_int4(x,&amp;k)) goto error;
-//	c-&gt;expires = k;
-//	
-//	if (!bin_decode_int2(x,	&amp;k)) goto error;
-//	c-&gt;service_route_cnt = k;
-//
-//	len = sizeof(str)*c-&gt;service_route_cnt;
-//	c-&gt;service_route = (str*) shm_malloc(len);
-//	if (!c-&gt;service_route) {
-//		LOG(L_ERR,&quot;ERR:&quot;M_NAME&quot;:bin_decode_r_subscription: Error allocating %d bytes.\n&quot;,len);
-//		goto error;
-//	}
-//	memset(c-&gt;service_route,0,len);	
-//	for(i=0;i&lt;c-&gt;service_route_cnt;i++)
-//		if (!bin_decode_str(x,&amp;st)||!str_shm_dup(c-&gt;service_route+i,&amp;st)) goto error;
-//	
-//	if (!bin_decode_pinhole(x,&amp;(c-&gt;pinhole ))) goto error;
-//		
-//	if (!bin_decode_int2(x,&amp;k)) goto error;
-//	for(i=0;i&lt;k;i++){
-//		p = bin_decode_r_public(x);
-//		if (!p) goto error;
-//		p-&gt;prev = c-&gt;tail;
-//		p-&gt;next = 0;
-//		if (c-&gt;tail) c-&gt;tail-&gt;next = p;
-//		c-&gt;tail = p;
-//		if (!c-&gt;head) c-&gt;head = p;
-//	}
-//	return c;
-//error:
-//	LOG(L_ERR,&quot;ERR:&quot;M_NAME&quot;:bin_decode_r_subscription: Error while decoding (at %d (%04x)).\n&quot;,x-&gt;max,x-&gt;max);
-//	if (c) {
-//		if (c-&gt;host.s) shm_free(c-&gt;host.s);		
-//		if (c-&gt;ipsec) shm_free(c-&gt;ipsec);
-//		if (c-&gt;uri.s) shm_free(c-&gt;uri.s);
-//		if (c-&gt;pinhole) shm_free(c-&gt;pinhole);
-//		while(c-&gt;head){
-//			p = c-&gt;head;
-//			pn = p-&gt;next;
-//			free_r_public(p);
-//			c-&gt;head = pn;
-//		}
-//		shm_free(c);
-//	}
-//	return 0;
-//}
-//
-//
-//
-//
+
+/**
+ * Encode a r_subscription into a binary form
+ * @param x - binary data to append to
+ * @param p - the r_subscription to encode
+ * @returns 1 on succcess or 0 on error
+ */
+int bin_encode_r_subscription(bin_data *x,r_subscription *s)
+{
+	char c;
+	
+	if (!bin_encode_str(x,&amp;(s-&gt;req_uri))) goto error;
+	if (!bin_encode_int(x,s-&gt;duration)) goto error;
+	if (!bin_encode_time_t(x,s-&gt;expires)) goto error;
+	
+	c = s-&gt;attempts_left;
+	if (!bin_encode_char(x,c)) goto error;
+
+	if (!bin_encode_dlg_t(x,s-&gt;dialog)) goto error;	
+	
+	return 1;
+error:
+	LOG(L_ERR,&quot;ERR:&quot;M_NAME&quot;:bin_encode_r_subscription: Error while encoding.\n&quot;);
+	return 0;		
+}
+
+/**
+ *	Decode a r_subscription from a binary data structure
+ * @param x - binary data to decode from
+ * @returns the r_subscription* where the data has been decoded
+ */
+r_subscription* bin_decode_r_subscription(bin_data *x)
+{
+	r_subscription *s=0;
+	int len;
+	str st;
+	char c;
+	
+	len = sizeof(r_subscription);
+	s = (r_subscription*) shm_malloc(len);
+	if (!s) {
+		LOG(L_ERR,&quot;ERR:&quot;M_NAME&quot;:bin_decode_r_subscription: Error allocating %d bytes.\n&quot;,len);
+		goto error;
+	}
+	memset(s,0,len);
+	
+	if (!bin_decode_str(x,&amp;st)||!str_shm_dup(&amp;(s-&gt;req_uri),&amp;st)) goto error;
+	if (!bin_decode_int(x,&amp;s-&gt;duration)) goto error;
+	if (!bin_decode_time_t(x,&amp;s-&gt;expires)) goto error;	
+	if (!bin_decode_char(x,&amp;c)) goto error;
+	s-&gt;attempts_left = c;
+	
+	if (!bin_decode_dlg_t(x,&amp;(s-&gt;dialog))) goto error;
+	
+	s-&gt;hash = get_subscription_hash(s-&gt;req_uri);
+	
+	return s;
+error:
+	LOG(L_ERR,&quot;ERR:&quot;M_NAME&quot;:bin_decode_r_subscription: Error while decoding (at %d (%04x)).\n&quot;,x-&gt;max,x-&gt;max);
+	if (s) {
+		if (s-&gt;req_uri.s) shm_free(s-&gt;req_uri.s);
+		if (s-&gt;dialog) tmb.free_dlg(s-&gt;dialog);		
+		shm_free(s);
+	}
+	return 0;
+}
+
+
+
+

Modified: ser_ims/branches/01_persistency/modules/pcscf/bin_pcscf.h
===================================================================
--- ser_ims/branches/01_persistency/modules/pcscf/bin_pcscf.h	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/pcscf/bin_pcscf.h	2007-02-08 00:14:53 UTC (rev 128)
@@ -61,6 +61,7 @@
 #include &quot;registrar_storage.h&quot;
 #include &quot;dlg_state.h&quot;
 #include &quot;registrar_subscribe.h&quot;
+#include &quot;../tm/tm_load.h&quot;
 
 #define BIN_INITIAL_ALLOC_SIZE 256
 
@@ -70,4 +71,7 @@
 int bin_encode_p_dialog(bin_data *x,p_dialog *d);
 p_dialog* bin_decode_p_dialog(bin_data *x);
 
+int bin_encode_r_subscription(bin_data *x,r_subscription *s);
+r_subscription* bin_decode_r_subscription(bin_data *x);
+
 #endif

Modified: ser_ims/branches/01_persistency/modules/pcscf/dlg_state.h
===================================================================
--- ser_ims/branches/01_persistency/modules/pcscf/dlg_state.h	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/pcscf/dlg_state.h	2007-02-08 00:14:53 UTC (rev 128)
@@ -88,11 +88,11 @@
 //	enum p_dialog_direction direction;
 	
 	str host;					/**&lt; host of the UE						*/
-	int port;					/**&lt; port of the UE						*/
-	int transport;				/**&lt; transport for the UE				*/
+	unsigned short port;					/**&lt; port of the UE						*/
+	char transport;				/**&lt; transport for the UE				*/
 	
 	str *routes;
-	int routes_cnt;
+	unsigned short routes_cnt;
 	
 	enum p_dialog_method method;
 	str method_str;

Modified: ser_ims/branches/01_persistency/modules/pcscf/mod.c
===================================================================
--- ser_ims/branches/01_persistency/modules/pcscf/mod.c	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/pcscf/mod.c	2007-02-08 00:14:53 UTC (rev 128)
@@ -170,6 +170,7 @@
 char* pcscf_persistency_location=&quot;/opt/OpenIMSCore/persistency&quot;;	/**&lt; where to dump the persistency data 	*/
 int pcscf_persistency_timer_dialogs=60;								/**&lt; interval to snapshot dialogs data		*/ 
 int pcscf_persistency_timer_registrar=60;							/**&lt; interval to snapshot registrar data	*/ 
+int pcscf_persistency_timer_subscriptions=60;						/**&lt; interval to snapshot subscriptions data*/ 
 
 
 int * shutdown_singleton;				/**&lt; Shutdown singleton 								*/
@@ -314,6 +315,7 @@
  * - persistency_location - where to dump/load the persistency data to/from
  * - persistency_timer_dialogs - interval to make dialogs data snapshots at
  * - persistency_timer_registrar - interval to make registrar snapshots at
+ * - persistency_timer_subscriptions - interval to make subscriptions snapshots at
  */	
 static param_export_t pcscf_params[]={ 
 	{&quot;name&quot;, STR_PARAM, &amp;pcscf_name},
@@ -361,6 +363,7 @@
 	{&quot;persistency_location&quot;, 			STR_PARAM, &amp;pcscf_persistency_location},
 	{&quot;persistency_timer_dialogs&quot;,		INT_PARAM, &amp;pcscf_persistency_timer_dialogs},
 	{&quot;persistency_timer_registrar&quot;,		INT_PARAM, &amp;pcscf_persistency_timer_registrar},
+	{&quot;persistency_timer_subscriptions&quot;,	INT_PARAM, &amp;pcscf_persistency_timer_subscriptions},
 	
 	{0,0,0} 
 };
@@ -579,6 +582,10 @@
 	
 	/* init the registrar subscriptions */
 	if (!r_subscription_init()) goto error;
+	if (pcscf_persistency_mode!=NO_PERSISTENCY){
+		load_snapshot_subscriptions();
+		if (register_timer(persistency_timer_subscriptions,0,pcscf_persistency_timer_subscriptions)&lt;0) goto error;
+	}
 
 	/* register the subscription timer */
 	if (register_timer(subscription_timer,registrar,5)&lt;0) goto error;
@@ -650,6 +657,7 @@
 		/* First let's snapshot everything */
 		make_snapshot_dialogs();
 		make_snapshot_registrar();
+		make_snapshot_subscriptions();
 		/* Then nuke it all */		
 		parser_destroy();
 		r_subscription_destroy();

Modified: ser_ims/branches/01_persistency/modules/pcscf/p_persistency.c
===================================================================
--- ser_ims/branches/01_persistency/modules/pcscf/p_persistency.c	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/pcscf/p_persistency.c	2007-02-08 00:14:53 UTC (rev 128)
@@ -204,3 +204,79 @@
 	make_snapshot_registrar();	 	
 }
 
+
+
+
+
+extern int subscriptions_hash_size;						/**&lt; Size of P-CSCF subscriptions hash table		*/
+extern r_subscription_hash_slot *subscriptions;				/**&lt; The P-CSCF subscriptions 						*/
+
+/**
+ * Creates a snapshots of the subscriptions and then calls the dumping function.
+ * @returns 1 on success or 0 on failure
+ */
+int make_snapshot_subscriptions()
+{
+	bin_data x;
+	r_subscription *s;
+	int i;	
+	if (!bin_alloc(&amp;x,256)) goto error;		
+	for(i=0;i&lt;subscriptions_hash_size;i++){
+		subs_lock(i);
+		s = subscriptions[i].head;
+		while(s){
+			if (!bin_encode_r_subscription(&amp;x,s)) goto error;
+			s = s-&gt;next;
+		}
+		subs_unlock(i);
+	}
+	bin_print(&amp;x);
+	i = bin_dump(&amp;x,pcscf_persistency_mode,pcscf_persistency_location,&quot;psubscriptions&quot;);		
+	bin_free(&amp;x);
+	return i;
+error:
+	return 0;
+}  
+
+/**
+ * Loads the subscriptions data from the last snapshot.
+ * @returns 1 on success or 0 on failure
+ */
+int load_snapshot_subscriptions()
+{
+	bin_data x;
+	r_subscription *s;
+	if (!bin_load(&amp;x,pcscf_persistency_mode,pcscf_persistency_location,&quot;psubscriptions&quot;)) goto error;
+	bin_print(&amp;x);
+	x.max=0;
+	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:load_snapshot_subscriptions: max %d len %d\n&quot;,x.max,x.len);
+	while(x.max&lt;x.len){
+		s = bin_decode_r_subscription(&amp;x);
+		if (!s) return 0;
+		LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:load_snapshot_subscriptions: Loaded r_subscription for &lt;%.*s&gt;\n&quot;,s-&gt;req_uri.len,s-&gt;req_uri.s);
+		subs_lock(s-&gt;hash);
+		s-&gt;prev = subscriptions[s-&gt;hash].tail;
+		s-&gt;next = 0;
+		if (subscriptions[s-&gt;hash].tail) subscriptions[s-&gt;hash].tail-&gt;next = s;
+		subscriptions[s-&gt;hash].tail = s;
+		if (!subscriptions[s-&gt;hash].head) subscriptions[s-&gt;hash].head = s;
+		subs_unlock(s-&gt;hash);
+	}
+	bin_free(&amp;x);
+	return 1;
+error:
+	return 0;
+	
+}
+
+
+/**
+ * Timer callback for persistency dumps
+ * @param ticks - what's the time
+ * @param param - a given parameter to be called with
+ */
+void persistency_timer_subscriptions(unsigned int ticks, void* param)
+{
+	make_snapshot_subscriptions();	 	
+}
+

Modified: ser_ims/branches/01_persistency/modules/pcscf/p_persistency.h
===================================================================
--- ser_ims/branches/01_persistency/modules/pcscf/p_persistency.h	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/pcscf/p_persistency.h	2007-02-08 00:14:53 UTC (rev 128)
@@ -68,4 +68,8 @@
 int load_snapshot_registrar();
 void persistency_timer_registrar(unsigned int ticks, void* param);
 
+int make_snapshot_subscriptions();
+int load_snapshot_subscriptions();
+void persistency_timer_subscriptions(unsigned int ticks, void* param);
+
 #endif

Modified: ser_ims/branches/01_persistency/modules/pcscf/registrar_storage.h
===================================================================
--- ser_ims/branches/01_persistency/modules/pcscf/registrar_storage.h	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/pcscf/registrar_storage.h	2007-02-08 00:14:53 UTC (rev 128)
@@ -67,7 +67,7 @@
 /** Registrar Public Identity Structure */
 typedef struct _r_public {
 	str aor;					/**&lt; the public identity 				*/
-	int is_default;				/**&lt; if this is the default id			*/			
+	char is_default;			/**&lt; if this is the default id			*/			
 	
 	struct _r_public *next;		/**&lt; next public identity for this contact */
 	struct _r_public *prev; 	/**&lt; previous public identity for this contact */
@@ -87,8 +87,8 @@
 	int spi_us;					/**&lt; SPI Server to use					*/	
 	int spi_pc;					/**&lt; SPI Client to use					*/
 	int spi_ps;					/**&lt; SPI Server to use					*/
-	int port_uc;				/**&lt; Port UE Client						*/
-	int port_us;				/**&lt; Port UE Server						*/
+	unsigned short port_uc;				/**&lt; Port UE Client						*/
+	unsigned short port_us;				/**&lt; Port UE Server						*/
 	
 	str ealg;					/**&lt; Cypher Algorithm - ESP				*/
 	str ck;						/**&lt; Cypher Key							*/
@@ -101,8 +101,8 @@
 	unsigned int hash;			/**&lt; the hash value 					*/
 	
 	str host;					/**&lt; host of the UE						*/
-	int port;					/**&lt; port of the UE						*/
-	int transport;				/**&lt; transport for the UE				*/
+	unsigned short port;					/**&lt; port of the UE						*/
+	char transport;				/**&lt; transport for the UE				*/
 	
 	r_ipsec *ipsec;				/**&lt; IPSec SA information, if any		*/
 	
@@ -111,8 +111,8 @@
 	enum Reg_States reg_state;	/**&lt; registration state					*/
 	time_t expires;				/**&lt; time of expiration					*/
 	
+	unsigned short service_route_cnt;		/**&lt; size of the above vector			*/
 	str *service_route;			/**&lt; service route entries				*/
-	int service_route_cnt;		/**&lt; size of the above vector			*/
 
 	r_nat_dest * pinhole;		/**&lt; address of the receive				*/ 
 	

Modified: ser_ims/branches/01_persistency/modules/pcscf/registrar_subscribe.c
===================================================================
--- ser_ims/branches/01_persistency/modules/pcscf/registrar_subscribe.c	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/pcscf/registrar_subscribe.c	2007-02-08 00:14:53 UTC (rev 128)
@@ -291,8 +291,8 @@
 	h.len += expires_s.len + 12 + expires_e.len;
 
 	h.len += contact_s.len + pcscf_name_str.len + contact_e.len;
-	if (pcscf_name_str.len) h.len += p_asserted_identity_s.len + 
-		p_asserted_identity_e.len + pcscf_name_str.len;
+	if (pcscf_path_str.len) h.len += p_asserted_identity_s.len + 
+		p_asserted_identity_e.len + pcscf_path_str.len;
 
 	h.s = pkg_malloc(h.len);
 	if (!h.s){
@@ -316,9 +316,9 @@
 	STR_APPEND(h,pcscf_name_str);
 	STR_APPEND(h,contact_e);
 	
-	if (pcscf_name_str.len) {
+	if (pcscf_path_str.len) {
 		STR_APPEND(h,p_asserted_identity_s);
-		STR_APPEND(h,pcscf_name_str);
+		STR_APPEND(h,pcscf_path_str);
 		STR_APPEND(h,p_asserted_identity_e);
 	}
 	

Modified: ser_ims/branches/01_persistency/modules/pcscf/registrar_subscribe.h
===================================================================
--- ser_ims/branches/01_persistency/modules/pcscf/registrar_subscribe.h	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/pcscf/registrar_subscribe.h	2007-02-08 00:14:53 UTC (rev 128)
@@ -92,11 +92,10 @@
 typedef struct _r_subscription {
 	unsigned int hash;
 	str req_uri;			/**&lt; public id of the user, same thing for To: 	*/
-//	str from;				/**&lt; own uri									*/
 	int duration;			/**&lt; duration of subscription					*/
-	int expires;			/**&lt; time of expiration							*/
-	int attempts_left;		/**&lt; number of unsuccesful attempts to subscribe*/
-//	str asserted_identity; 	/**&lt; uri inserted into path					*/
+	time_t expires;			/**&lt; time of expiration							*/
+	char attempts_left;		/**&lt; number of unsuccesful attempts to subscribe*/
+
 	dlg_t *dialog; 
 		
 	struct _r_subscription *next, *prev;
@@ -109,8 +108,9 @@
 	r_subscription *tail;	/**&lt; last subscription in the list			*/ 
 } r_subscription_hash_slot;
 
-
- 
+void subs_lock(unsigned int hash);
+void subs_unlock(unsigned int hash);
+unsigned int get_subscription_hash(str uri);
 int r_subscription_init();
 void r_subscription_destroy();
 

Modified: ser_ims/branches/01_persistency/modules/scscf/bin.c
===================================================================
--- ser_ims/branches/01_persistency/modules/scscf/bin.c	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/scscf/bin.c	2007-02-08 00:14:53 UTC (rev 128)
@@ -66,7 +66,7 @@
 /** 
  * Whether to print debug message while encoding/decoding 
  */
-#define BIN_DEBUG 0
+#define BIN_DEBUG 1
 
 /** 
  * Whether to do sanity checks on the available data when decoding
@@ -150,108 +150,129 @@
 }
 
 
+
+
+
+
+
 /* basic data type reprezentation functions */
 
+
+
+
 /**
- *	Append an integer of 1 byte 
+ *	Append a char of 1 byte 
  */
-inline int bin_encode_int1(bin_data *x,int k) 
+inline int bin_encode_char(bin_data *x,char k) 
 { 
 	if (!bin_expand(x,1)) return 0;
-	if (k&gt;0xff) 
-		LOG(L_ERR,&quot;ERROR:&quot;M_NAME&quot;:bin_encode_int1: Possible loss in encoding (int &gt; 0xff bytes) %d bytes \n&quot;,k);
-	x-&gt;s[x-&gt;len++]=k &amp; 0x000000FF; 
+	x-&gt;s[x-&gt;len++]= k; 
 #if BIN_DEBUG	
-	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_encode_int1: [%d]:[%.02x] new len %04x\n&quot;,k,x-&gt;s[x-&gt;len-1],x-&gt;len);
+	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_encode_char: [%d]:[%.02x] new len %04x\n&quot;,k,x-&gt;s[x-&gt;len-1],x-&gt;len);
 #endif
 	return 1;   
 }
-
 /**
- *	Append an integer of 2 bytes 
+ *	Decode of 1 char
  */
-inline int bin_encode_int2(bin_data *x,int k) 
-{ 
-	if (!bin_expand(x,2)) return 0;
-	if (k&gt;0xffff) 
-		LOG(L_ERR,&quot;ERROR:&quot;M_NAME&quot;:bin_encode_int2: Possible loss in encoding (int &gt; 0xffff bytes) %d bytes \n&quot;,k);
-	x-&gt;s[x-&gt;len++]=k &amp; 0x000000FF;    
-	x-&gt;s[x-&gt;len++]=(k &amp; 0x0000FF00) &gt;&gt; 8;   
+inline int bin_decode_char(bin_data *x,char *c)
+{
+#if BIN_DECODE_CHECKS
+	if (x-&gt;max+1 &gt; x-&gt;len) return 0;
+#endif	
+	*c = x-&gt;s[x-&gt;max];
+	x-&gt;max += 1;
 #if BIN_DEBUG	
-	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_encode_int2: [%d]:[%.02x %.02x] new len %04x\n&quot;,k,x-&gt;s[x-&gt;len-2],x-&gt;s[x-&gt;len-1],x-&gt;len);
+	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_decode_char: [%d] new pos %04x\n&quot;,*c,x-&gt;max);
 #endif
-	return 1;   
+	return 1;
 }
 
+
+
+
 /**
- *	Append an integer of 4 bytes
+ *	Append an unsigned char of 1 byte 
  */
-inline int bin_encode_int4(bin_data *x,int k) 
+inline int bin_encode_uchar(bin_data *x,unsigned char k) 
 { 
-	if (!bin_expand(x,4)) return 0;
-	if (k&gt;0xffffffff) 
-		LOG(L_ERR,&quot;ERROR:&quot;M_NAME&quot;:bin_encode_int4: Possible loss in encoding (int &gt; 0xffffffff bytes) %d bytes \n&quot;,k);
-	x-&gt;s[x-&gt;len++]= k &amp; 0x000000FF;          
-	x-&gt;s[x-&gt;len++]=(k &amp; 0x0000FF00) &gt;&gt; 8;    
-	x-&gt;s[x-&gt;len++]=(k &amp; 0x00FF0000) &gt;&gt;16;    
-	x-&gt;s[x-&gt;len++]=(k &amp; 0xFF000000) &gt;&gt;24;
-#if BIN_DEBUG		    
-	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_encode_int4: [%d]:[%.02x %.02x %.02x %.02x] new len %04x\n&quot;,k,
-		x-&gt;s[x-&gt;len-4],x-&gt;s[x-&gt;len-3],x-&gt;s[x-&gt;len-2],x-&gt;s[x-&gt;len-1],x-&gt;len);
-#endif		
+	if (!bin_expand(x,1)) return 0;
+	x-&gt;s[x-&gt;len++]= k; 
+#if BIN_DEBUG	
+	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_encode_uchar: [%u]:[%.02x] new len %04x\n&quot;,k,x-&gt;s[x-&gt;len-1],x-&gt;len);
+#endif
 	return 1;   
 }
-
 /**
- *	Append a string 
+ *	Decode of 1 unsigned char
  */
-inline int bin_encode_str(bin_data *x,str *s) 
-{ 
-	if (!bin_expand(x,2+s-&gt;len)) return 0;
-	if (s-&gt;len&gt;65535) 
-		LOG(L_ERR,&quot;ERROR:&quot;M_NAME&quot;:bin_encode_str: Possible loss of characters in encoding (string &gt; 65535bytes) %d bytes \n&quot;,s-&gt;len);
-	x-&gt;s[x-&gt;len++]=s-&gt;len &amp; 0x000000FF;
-	x-&gt;s[x-&gt;len++]=(s-&gt;len &amp; 0x0000FF00)&gt;&gt;8;
-	memcpy(x-&gt;s+x-&gt;len,s-&gt;s,s-&gt;len);
-	x-&gt;len+=s-&gt;len;
-#if BIN_DEBUG		
-	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_encode_str : [%d]:[%.02x %.02x]:[%.*s] new len %04x\n&quot;,s-&gt;len,
-		x-&gt;s[x-&gt;len-s-&gt;len-2],x-&gt;s[x-&gt;len-s-&gt;len-1],s-&gt;len,s-&gt;s,x-&gt;len);
-#endif		
-	return 1;   
+inline int bin_decode_uchar(bin_data *x,unsigned char *c)
+{
+#if BIN_DECODE_CHECKS
+	if (x-&gt;max+1 &gt; x-&gt;len) return 0;
+#endif	
+	*c = x-&gt;s[x-&gt;max];
+	x-&gt;max += 1;
+#if BIN_DEBUG	
+	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_decode_uchar: [%u] new pos %04x\n&quot;,*c,x-&gt;max);
+#endif
+	return 1;
 }
 
 
 
 
-/* advanced data type reprezentation functions */
 
 
 
 /**
- * Decoding into structures functions, without allocating new space for data
+ *	Append the a short  
  */
-
+inline int bin_encode_short(bin_data *x,short k) 
+{ 
+	if (!bin_expand(x,2)) return 0;
+	x-&gt;s[x-&gt;len++]=k &amp; 0x00FF;    
+	x-&gt;s[x-&gt;len++]=(k &amp; 0xFF00) &gt;&gt; 8;   
+#if BIN_DEBUG	
+	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_encode_short: [%d]:[%.02x %.02x] new len %04x\n&quot;,k,x-&gt;s[x-&gt;len-2],x-&gt;s[x-&gt;len-1],x-&gt;len);
+#endif
+	return 1;   
+}
 /**
- *	Decode of 1 byte integer
+ *	Decode of a short
  */
-inline int bin_decode_int1(bin_data *x,int *v)
+inline int bin_decode_short(bin_data *x,short *v)
 {
 #if BIN_DECODE_CHECKS
-	if (x-&gt;max+1 &gt; x-&gt;len) return 0;
-#endif	
-	*v = (unsigned char)x-&gt;s[x-&gt;max];
-	x-&gt;max += 1;
+	if (x-&gt;max+2 &gt; x-&gt;len) return 0;
+#endif
+	*v =	(unsigned char)x-&gt;s[x-&gt;max  ]    |
+	 		(unsigned char)x-&gt;s[x-&gt;max+1]&lt;&lt;8;
+	x-&gt;max += 2;
 #if BIN_DEBUG	
-	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_decode_int1: [%d] new pos %04x\n&quot;,*v,x-&gt;max);
+	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_decode_short: [%d] new pos %04x\n&quot;,*v,x-&gt;max);
 #endif
 	return 1;
 }
 
+
 /**
- *	Decode of 2 byte integer
+ *	Append the an unsigned short  
  */
-inline int bin_decode_int2(bin_data *x,int *v)
+inline int bin_encode_ushort(bin_data *x,unsigned short k) 
+{ 
+	if (!bin_expand(x,2)) return 0;
+	x-&gt;s[x-&gt;len++]=k &amp; 0x00FF;    
+	x-&gt;s[x-&gt;len++]=(k &amp; 0xFF00) &gt;&gt; 8;   
+#if BIN_DEBUG	
+	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_encode_ushort: [%u]:[%.02x %.02x] new len %04x\n&quot;,k,x-&gt;s[x-&gt;len-2],x-&gt;s[x-&gt;len-1],x-&gt;len);
+#endif
+	return 1;   
+}
+/**
+ *	Decode of a short
+ */
+inline int bin_decode_ushort(bin_data *x,unsigned short *v)
 {
 #if BIN_DECODE_CHECKS
 	if (x-&gt;max+2 &gt; x-&gt;len) return 0;
@@ -260,31 +281,169 @@
 	 		(unsigned char)x-&gt;s[x-&gt;max+1]&lt;&lt;8;
 	x-&gt;max += 2;
 #if BIN_DEBUG	
-	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_decode_int2: [%d] new pos %04x\n&quot;,*v,x-&gt;max);
+	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_decode_ushort: [%u] new pos %04x\n&quot;,*v,x-&gt;max);
 #endif
 	return 1;
 }
 
+
 /**
- *	Decode of 4 byte integer
+ *	Append an integer
  */
-inline int bin_decode_int4(bin_data *x,int *v)
+inline int bin_encode_int(bin_data *x,int k) 
+{ 
+	int len = sizeof(int),i;
+	if (!bin_expand(x,len)) return 0;
+	for(i=0;i&lt;len;i++){
+		x-&gt;s[x-&gt;len++]= k &amp; 0xFF;
+		k = k&gt;&gt;8;          
+	}
+#if BIN_DEBUG		    
+	switch(len){
+		case 4:
+			LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_encode_int: [%d]:[%.02x %.02x %.02x %.02x] new len %04x\n&quot;,k,
+				x-&gt;s[x-&gt;len-4],x-&gt;s[x-&gt;len-3],x-&gt;s[x-&gt;len-2],x-&gt;s[x-&gt;len-1],x-&gt;len);
+			break;
+		case 8:
+			LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_encode_int: [%d]:[%.02x %.02x %.02x %.02x%.02x %.02x %.02x %.02x] new len %04x\n&quot;,k,
+				x-&gt;s[x-&gt;len-8],x-&gt;s[x-&gt;len-7],x-&gt;s[x-&gt;len-6],x-&gt;s[x-&gt;len-5],
+				x-&gt;s[x-&gt;len-4],x-&gt;s[x-&gt;len-3],x-&gt;s[x-&gt;len-2],x-&gt;s[x-&gt;len-1],
+				x-&gt;len);
+			break;
+	}
+#endif		
+	return 1;   
+}
+/**
+ *	Decode an integer
+ */
+inline int bin_decode_int(bin_data *x,int *v)
 {
+	int len = sizeof(int),i;
 #if BIN_DECODE_CHECKS
-	if (x-&gt;max+4 &gt; x-&gt;len) return 0;
+	if (x-&gt;max+len &gt; x-&gt;len) return 0;
 #endif
-	*v =    (unsigned char)x-&gt;s[x-&gt;max  ] 		|
-			(unsigned char)x-&gt;s[x-&gt;max+1] &lt;&lt;8 	|
-		  	(unsigned char)x-&gt;s[x-&gt;max+2] &lt;&lt;16 	|
-		  	(unsigned char)x-&gt;s[x-&gt;max+3] &lt;&lt;24 	;
-	x-&gt;max += 4;
+	*v = 0;
+	for(i=0;i&lt;len;i++)
+		*v =  *v | ((unsigned char)x-&gt;s[x-&gt;max++] &lt;&lt;(8*i));
 #if BIN_DEBUG	
-	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_decode_int4: [%d] new pos %04x\n&quot;,*v,x-&gt;max);
+	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_decode_int: [%d] new pos %04x\n&quot;,*v,x-&gt;max);
 #endif
 	return 1;
 }
 
+
+
 /**
+ *	Append an unsigned integer
+ */
+inline int bin_encode_uint(bin_data *x,unsigned int k) 
+{ 
+	int len = sizeof(unsigned int),i;
+	if (!bin_expand(x,len)) return 0;
+	for(i=0;i&lt;len;i++){
+		x-&gt;s[x-&gt;len++]= k &amp; 0xFF;
+		k = k&gt;&gt;8;          
+	}
+#if BIN_DEBUG		    
+	switch(len){
+		case 4:
+			LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_encode_uint: [%u]:[%.02x %.02x %.02x %.02x] new len %04x\n&quot;,k,
+				x-&gt;s[x-&gt;len-4],x-&gt;s[x-&gt;len-3],x-&gt;s[x-&gt;len-2],x-&gt;s[x-&gt;len-1],x-&gt;len);
+			break;
+		case 8:
+			LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_encode_uint: [%u]:[%.02x %.02x %.02x %.02x%.02x %.02x %.02x %.02x] new len %04x\n&quot;,k,
+				x-&gt;s[x-&gt;len-8],x-&gt;s[x-&gt;len-7],x-&gt;s[x-&gt;len-6],x-&gt;s[x-&gt;len-5],
+				x-&gt;s[x-&gt;len-4],x-&gt;s[x-&gt;len-3],x-&gt;s[x-&gt;len-2],x-&gt;s[x-&gt;len-1],
+				x-&gt;len);
+			break;
+	}
+#endif		
+	return 1;   
+}
+/**
+ *	Decode an unsigned integer
+ */
+inline int bin_decode_uint(bin_data *x,unsigned int *v)
+{
+	int len = sizeof(unsigned int),i;
+#if BIN_DECODE_CHECKS
+	if (x-&gt;max+len &gt; x-&gt;len) return 0;
+#endif
+	*v = 0;
+	for(i=0;i&lt;len;i++)
+		*v =  *v | ((unsigned char)x-&gt;s[x-&gt;max++] &lt;&lt;(8*i));
+#if BIN_DEBUG	
+	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_decode_uint: [%u] new pos %04x\n&quot;,*v,x-&gt;max);
+#endif
+	return 1;
+}
+
+/**
+ *	Append a time_t structure
+ */
+inline int bin_encode_time_t(bin_data *x,time_t k) 
+{ 
+	int len = sizeof(time_t),i;
+	if (!bin_expand(x,len)) return 0;
+	for(i=0;i&lt;len;i++){
+		x-&gt;s[x-&gt;len++]= k &amp; 0xFF;
+		k = k&gt;&gt;8;          
+	}
+#if BIN_DEBUG		    
+	switch(len){
+		case 4:
+			LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_encode_time_t: [%u]:[%.02x %.02x %.02x %.02x] new len %04x\n&quot;,(unsigned int)k,
+				x-&gt;s[x-&gt;len-4],x-&gt;s[x-&gt;len-3],x-&gt;s[x-&gt;len-2],x-&gt;s[x-&gt;len-1],x-&gt;len);
+			break;
+		case 8:
+			LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_encode_time_t: [%u]:[%.02x %.02x %.02x %.02x%.02x %.02x %.02x %.02x] new len %04x\n&quot;,(unsigned int)k,
+				x-&gt;s[x-&gt;len-8],x-&gt;s[x-&gt;len-7],x-&gt;s[x-&gt;len-6],x-&gt;s[x-&gt;len-5],
+				x-&gt;s[x-&gt;len-4],x-&gt;s[x-&gt;len-3],x-&gt;s[x-&gt;len-2],x-&gt;s[x-&gt;len-1],
+				x-&gt;len);
+			break;
+	}
+#endif		
+	return 1;   
+}
+/**
+ *	Decode an unsigned integer
+ */
+inline int bin_decode_time_t(bin_data *x,time_t *v)
+{
+	int len = sizeof(time_t),i;
+#if BIN_DECODE_CHECKS
+	if (x-&gt;max+len &gt; x-&gt;len) return 0;
+#endif
+	*v = 0;
+	for(i=0;i&lt;len;i++)
+		*v =  *v | ((unsigned char)x-&gt;s[x-&gt;max++] &lt;&lt;(8*i));
+#if BIN_DEBUG	
+	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_decode_time_t: [%u] new pos %04x\n&quot;,(unsigned int) *v,x-&gt;max);
+#endif
+	return 1;
+}
+
+
+/**
+ *	Append a string 
+ */
+inline int bin_encode_str(bin_data *x,str *s) 
+{ 
+	if (!bin_expand(x,2+s-&gt;len)) return 0;
+	if (s-&gt;len&gt;65535) 
+		LOG(L_ERR,&quot;ERROR:&quot;M_NAME&quot;:bin_encode_str: Possible loss of characters in encoding (string &gt; 65535bytes) %d bytes \n&quot;,s-&gt;len);
+	x-&gt;s[x-&gt;len++]=s-&gt;len &amp; 0x000000FF;
+	x-&gt;s[x-&gt;len++]=(s-&gt;len &amp; 0x0000FF00)&gt;&gt;8;
+	memcpy(x-&gt;s+x-&gt;len,s-&gt;s,s-&gt;len);
+	x-&gt;len+=s-&gt;len;
+#if BIN_DEBUG		
+	LOG(L_INFO,&quot;INFO:&quot;M_NAME&quot;:bin_encode_str : [%d]:[%.02x %.02x]:[%.*s] new len %04x\n&quot;,s-&gt;len,
+		x-&gt;s[x-&gt;len-s-&gt;len-2],x-&gt;s[x-&gt;len-s-&gt;len-1],s-&gt;len,s-&gt;s,x-&gt;len);
+#endif		
+	return 1;   
+}
+/**
  *	Decode of a str string
  */
 inline int bin_decode_str(bin_data *x,str *s)
@@ -295,7 +454,7 @@
 	s-&gt;len = (unsigned char)x-&gt;s[x-&gt;max  ]    |
 	 		(unsigned char)x-&gt;s[x-&gt;max+1]&lt;&lt;8;
 	x-&gt;max +=2;
-	if (x-&gt;max+s-&gt;len&gt;=x-&gt;len) return 0;
+	if (x-&gt;max+s-&gt;len&gt;x-&gt;len) return 0;
 	s-&gt;s = x-&gt;s + x-&gt;max;
 	x-&gt;max += s-&gt;len;
 #if BIN_DEBUG	
@@ -306,6 +465,10 @@
 
 
 
+
+/* complex data types */
+
+
 extern dlg_func_t dialogb;							/**&lt; Structure with pointers to dialog funcs			*/
 
 
@@ -369,6 +532,10 @@
 
 
 
+
+/* file dumping routines */
+
+
 int bin_files_keep_count=3;				/**&lt; how many old snapshots to keep				*/
 
 

Modified: ser_ims/branches/01_persistency/modules/scscf/bin.h
===================================================================
--- ser_ims/branches/01_persistency/modules/scscf/bin.h	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/scscf/bin.h	2007-02-08 00:14:53 UTC (rev 128)
@@ -128,22 +128,31 @@
 inline void bin_free(bin_data *x);
 inline void bin_print(bin_data *x);
 
-inline int bin_encode_int1(bin_data *x,int k); 
-inline int bin_encode_int2(bin_data *x,int k);
-inline int bin_encode_int4(bin_data *x,int k);
+inline int bin_encode_char(bin_data *x,char k);
+inline int bin_decode_char(bin_data *x,char *c);
+
+inline int bin_encode_uchar(bin_data *x,unsigned char k); 
+inline int bin_decode_uchar(bin_data *x,unsigned char *c);
+
+inline int bin_encode_short(bin_data *x,short k);
+inline int bin_decode_short(bin_data *x,short *c);
+
+inline int bin_encode_ushort(bin_data *x,unsigned short k); 
+inline int bin_decode_ushort(bin_data *x,unsigned short *c);
+
+inline int bin_encode_int(bin_data *x,int k);
+inline int bin_decode_int(bin_data *x,int *c);
+
+inline int bin_encode_uint(bin_data *x,unsigned int k); 
+inline int bin_decode_uint(bin_data *x,unsigned int *c);
+
+inline int bin_encode_time_t(bin_data *x,time_t k);
+inline int bin_decode_time_t(bin_data *x,time_t *c);
+
 inline int bin_encode_str(bin_data *x,str *s);
-
-inline int bin_decode_int1(bin_data *x,int *k);
-inline int bin_decode_int2(bin_data *x,int *k);
-inline int bin_decode_int4(bin_data *x,int *k);
 inline int bin_decode_str(bin_data *x,str *s);
 
 
-/**
- *	simple print function 
- */
-void bin_print(bin_data *s);
-
 int bin_encode_dlg_t(bin_data *x,dlg_t *d);
 int bin_decode_dlg_t(bin_data *x,dlg_t **d);
 

Modified: ser_ims/branches/01_persistency/modules/scscf/bin_scscf.c
===================================================================
--- ser_ims/branches/01_persistency/modules/scscf/bin_scscf.c	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/scscf/bin_scscf.c	2007-02-08 00:14:53 UTC (rev 128)
@@ -54,7 +54,7 @@
 
 #include &quot;bin_scscf.h&quot;
 
-/* structures reprezentation functions */
+extern struct tm_binds tmb;   		/**&lt; Structure with pointers to tm funcs 		*/
 
 extern int r_hash_size;						/**&lt; Size of S-CSCF registrar hash table		*/
 
@@ -79,7 +79,7 @@
  */
 static int bin_encode_public_identity(bin_data *x,ims_public_identity *pi)
 {
-	if (!bin_encode_int1(x,pi-&gt;barring)) goto error;
+	if (!bin_encode_char(x,pi-&gt;barring)) goto error;
 	if (!bin_encode_str(x,&amp;(pi-&gt;public_identity))) goto error;	
 	return 1;
 error:
@@ -96,7 +96,7 @@
 static int bin_decode_public_identity(bin_data *x,ims_public_identity *pi)
 {
 	str s;
-	if (!bin_decode_int1(x,	&amp;(pi-&gt;barring))) goto error;
+	if (!bin_decode_char(x,	&amp;(pi-&gt;barring))) goto error;
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(pi-&gt;public_identity),&amp;s))	goto error;
 	
 	return 1;
@@ -121,11 +121,12 @@
  */
 static int bin_encode_spt(bin_data *x, ims_spt *spt)
 {
+	unsigned char c = spt-&gt;condition_negated&lt;&lt;7 | spt-&gt;registration_type&lt;&lt;4 | spt-&gt;type;
 	// cond negated, reg type, spt type
-	if (!bin_encode_int1(x,spt-&gt;condition_negated&lt;&lt;7 | spt-&gt;registration_type&lt;&lt;4 | spt-&gt;type)) goto error;
+	if (!bin_encode_uchar(x,c)) goto error;
 
 	//group
-	if (!bin_encode_int2(x,spt-&gt;group)) goto error;
+	if (!bin_encode_int(x,spt-&gt;group)) goto error;
 
 	//spt
 	switch(spt-&gt;type){
@@ -136,12 +137,12 @@
 			if (!bin_encode_str(x,&amp;(spt-&gt;method))) goto error; 
 			break;
 		case 3:
-			if (!bin_encode_int1(x,spt-&gt;sip_header.type)) goto error;
+			if (!bin_encode_short(x,spt-&gt;sip_header.type)) goto error;
 			if (!bin_encode_str(x,&amp;(spt-&gt;sip_header.header))) goto error; 
 			if (!bin_encode_str(x,&amp;(spt-&gt;sip_header.content))) goto error; 
 			break;
 		case 4:
-			if (!bin_encode_int1(x,spt-&gt;session_case)) goto error;
+			if (!bin_encode_char(x,spt-&gt;session_case)) goto error;
 			break;
 		case 5:
 			if (!bin_encode_str(x,&amp;(spt-&gt;session_desc.line))) goto error; 
@@ -163,16 +164,16 @@
  */
 static int bin_decode_spt(bin_data *x, ims_spt *spt)
 {
-	int k;
+	unsigned char k;
 	str s;
 	
-	if (!bin_decode_int1(x,&amp;k)) goto error;
+	if (!bin_decode_uchar(x,&amp;k)) goto error;
 	
 	spt-&gt;type = k &amp; 0x0F;
 	spt-&gt;condition_negated = ((k &amp; 0x80)!=0);
 	spt-&gt;registration_type = ((k &amp; 0x70)&gt;&gt;4);
 	
-	if (!bin_decode_int2(x,&amp;(spt-&gt;group))) goto error;
+	if (!bin_decode_int(x,&amp;(spt-&gt;group))) goto error;
 
 	switch (spt-&gt;type){
 		case 1:
@@ -182,13 +183,12 @@
 			if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(spt-&gt;method),&amp;s)) goto error;
 			break;
 		case 3:
-			if (!bin_decode_int1(x,&amp;(spt-&gt;sip_header.type))) goto error;
+			if (!bin_decode_short(x,&amp;(spt-&gt;sip_header.type))) goto error;
 			if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(spt-&gt;sip_header.header),&amp;s)) goto error;
 			if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(spt-&gt;sip_header.content),&amp;s)) goto error;
-			//TODO - compute the regex!!!
 			break;
 		case 4:
-			if (!bin_decode_int1(x,&amp;(spt-&gt;session_case))) goto error;
+			if (!bin_decode_char(x,&amp;(spt-&gt;session_case))) goto error;
 			break;
 		case 5:
 			if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(spt-&gt;session_desc.line),&amp;s)) goto error;
@@ -232,31 +232,32 @@
  */
 static int bin_encode_filter_criteria(bin_data *x, ims_filter_criteria *fc)
 {
-	int i,ppindicator;
+	int i;
+	char ppindicator;
 
 	//priority
-	if (!bin_encode_int4(x,fc-&gt;priority)) goto error;
+	if (!bin_encode_int(x,fc-&gt;priority)) goto error;
 	
 	//profile part indicator
 	if (fc-&gt;profile_part_indicator) ppindicator = (*fc-&gt;profile_part_indicator)+1;
 	else ppindicator = 0;
-	if (!bin_encode_int1(x,ppindicator)) goto error;
+	if (!bin_encode_char(x,ppindicator)) goto error;
 			
 	// trigger point 
 	if (fc-&gt;trigger_point) {
-		if (!bin_encode_int1(x,fc-&gt;trigger_point-&gt;condition_type_cnf)) goto error;
+		if (!bin_encode_char(x,fc-&gt;trigger_point-&gt;condition_type_cnf)) goto error;
 		
-		if (!bin_encode_int2(x,fc-&gt;trigger_point-&gt;spt_cnt)) goto error;
+		if (!bin_encode_ushort(x,fc-&gt;trigger_point-&gt;spt_cnt)) goto error;
 		
 		for(i=0;i&lt;fc-&gt;trigger_point-&gt;spt_cnt;i++)
 			if (!bin_encode_spt(x,fc-&gt;trigger_point-&gt;spt+i)) goto error;
 	} else {
-		if (!bin_encode_int1(x,0xFF)) goto error;
+		if (!bin_encode_char(x,100)) goto error;
 	}
 	
 	//app server
 	if (!bin_encode_str(x,&amp;(fc-&gt;application_server.server_name))) goto error;
-	if (!bin_encode_int1(x,fc-&gt;application_server.default_handling)) goto error;
+	if (!bin_encode_char(x,fc-&gt;application_server.default_handling)) goto error;
 	if (!bin_encode_str(x,&amp;(fc-&gt;application_server.service_info))) goto error;
 	
 	return 1;
@@ -274,19 +275,20 @@
  */
 static int bin_decode_filter_criteria(bin_data *x, ims_filter_criteria *fc)
 {
-	int cnf,i,ppindicator,len,k;
+	int i,len;
 	str s;
+	char ppindicator,cnf;
 	
 	//priority
-	if (!bin_decode_int4(x,&amp;(fc-&gt;priority))) goto error;
+	if (!bin_decode_int(x,&amp;(fc-&gt;priority))) goto error;
 	
 	// profile part indicator
-	if (!bin_decode_int1(x,&amp;ppindicator)) goto error;
+	if (!bin_decode_char(x,&amp;ppindicator)) goto error;
 	if (!ppindicator){
 		fc-&gt;profile_part_indicator = 0;
 	}
 	else {
-		fc-&gt;profile_part_indicator = (int*)shm_malloc(sizeof(int));
+		fc-&gt;profile_part_indicator = (char*)shm_malloc(sizeof(char));
 		if (!fc-&gt;profile_part_indicator) {
 			LOG(L_ERR,&quot;ERR:&quot;M_NAME&quot;:bin_decode_filter_criteria: Error allocating %d bytes.\n&quot;,sizeof(int));
 			goto error;
@@ -295,9 +297,9 @@
 	}
 	
 	//cnf 
-	if (!bin_decode_int1(x,&amp;cnf)) goto error;
+	if (!bin_decode_char(x,&amp;cnf)) goto error;
 
-	if (cnf==0xFF)
+	if (cnf==100)
 		fc-&gt;trigger_point=NULL;
 	else {
 		ims_trigger_point *tp=0;
@@ -312,8 +314,7 @@
 		memset(tp,0,len);
 		tp-&gt;condition_type_cnf=cnf;
 		
-		if (!bin_decode_int2(x,&amp;k)) goto error;
-		tp-&gt;spt_cnt = k;
+		if (!bin_decode_ushort(x,&amp;tp-&gt;spt_cnt)) goto error;
 		len = sizeof(ims_spt)*tp-&gt;spt_cnt;
 		tp-&gt;spt = (ims_spt*)shm_malloc(len);
 		if (!tp-&gt;spt) {
@@ -327,7 +328,7 @@
 	//app server uri
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(fc-&gt;application_server.server_name),&amp;s)) goto error;
 	// app server default handling
-	if (!bin_decode_int1(x,&amp;(fc-&gt;application_server.default_handling)))goto error;
+	if (!bin_decode_char(x,&amp;(fc-&gt;application_server.default_handling)))goto error;
 	// app server service info
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(fc-&gt;application_server.service_info),&amp;s)) goto error;
 
@@ -363,12 +364,12 @@
 	int i;
 		
 	//public identity
-	if (!bin_encode_int2(x,sp-&gt;public_identities_cnt)) return 0;
+	if (!bin_encode_ushort(x,sp-&gt;public_identities_cnt)) return 0;
 	for(i=0;i&lt;sp-&gt;public_identities_cnt;i++)
 		if (!bin_encode_public_identity(x,sp-&gt;public_identities+i)) goto error;
 	
 	//filter criteria
-	if (!bin_encode_int2(x,sp-&gt;filter_criteria_cnt)) return 0;
+	if (!bin_encode_ushort(x,sp-&gt;filter_criteria_cnt)) return 0;
 	for(i=0;i&lt;sp-&gt;filter_criteria_cnt;i++)
 		if (!bin_encode_filter_criteria(x,sp-&gt;filter_criteria+i)) goto error;
 		
@@ -376,12 +377,12 @@
 	if (sp-&gt;cn_service_auth)
 		i = sp-&gt;cn_service_auth-&gt;subscribed_media_profile_id;
 	else i = 0xFFFFFFFF;
-	if (!bin_encode_int4(x,i)) goto error;
+	if (!bin_encode_int(x,i)) goto error;
 
 	//shared_ifc
-	if (!bin_encode_int2(x,sp-&gt;shared_ifc_set_cnt)) return 0;
+	if (!bin_encode_ushort(x,sp-&gt;shared_ifc_set_cnt)) return 0;
 	for(i=0;i&lt;sp-&gt;shared_ifc_set_cnt;i++)
-		if (!bin_encode_int4(x,sp-&gt;shared_ifc_set[i])) goto error;
+		if (!bin_encode_int(x,sp-&gt;shared_ifc_set[i])) goto error;
 
 	return 1;
 error:
@@ -401,7 +402,7 @@
 	int i,len;
 
 	//public identities
-	if (!bin_decode_int2(x,&amp;(sp-&gt;public_identities_cnt))) goto error;
+	if (!bin_decode_ushort(x,&amp;(sp-&gt;public_identities_cnt))) goto error;
 	len = sizeof(ims_public_identity)*sp-&gt;public_identities_cnt;
 	sp-&gt;public_identities = (ims_public_identity*)shm_malloc(len);
 	if (!sp-&gt;public_identities) {
@@ -413,7 +414,7 @@
 		if (!bin_decode_public_identity(x,sp-&gt;public_identities+i)) goto error;
 	
 	// filter criteria
-	if (!bin_decode_int2(x,&amp;(sp-&gt;filter_criteria_cnt))) goto error;	
+	if (!bin_decode_ushort(x,&amp;(sp-&gt;filter_criteria_cnt))) goto error;	
 	len = sizeof(ims_filter_criteria)*sp-&gt;filter_criteria_cnt;
 	sp-&gt;filter_criteria = (ims_filter_criteria*)shm_malloc(len);
 	if (!sp-&gt;filter_criteria) {
@@ -425,7 +426,7 @@
 		if (!bin_decode_filter_criteria(x,sp-&gt;filter_criteria+i)) goto error;
 
 	// cn service auth
-	if (!bin_decode_int4(x,&amp;i)) goto error;
+	if (!bin_decode_int(x,&amp;i)) goto error;
 	if (i==0xFFFFFFFF)
 		sp-&gt;cn_service_auth = 0;
 	else {
@@ -439,7 +440,7 @@
 	}
 	
 	//shared ifc
-	if (!bin_decode_int2(x,&amp;(sp-&gt;shared_ifc_set_cnt))) goto error;	
+	if (!bin_decode_ushort(x,&amp;(sp-&gt;shared_ifc_set_cnt))) goto error;	
 	len = sizeof(int)*sp-&gt;shared_ifc_set_cnt;
 	sp-&gt;shared_ifc_set = (int*)shm_malloc(len);
 	if (!sp-&gt;shared_ifc_set) {
@@ -448,7 +449,7 @@
 	}
 	memset(sp-&gt;shared_ifc_set,0,len);
 	for(i=0;i&lt;sp-&gt;shared_ifc_set_cnt;i++)
-		if (!bin_decode_int4(x,sp-&gt;shared_ifc_set+i)) goto error;
+		if (!bin_decode_int(x,sp-&gt;shared_ifc_set+i)) goto error;
 
 	return 1;
 error:
@@ -458,7 +459,6 @@
 		if (sp-&gt;filter_criteria) shm_free(sp-&gt;filter_criteria);
 		if (sp-&gt;cn_service_auth) shm_free(sp-&gt;cn_service_auth);
 		if (sp-&gt;shared_ifc_set) shm_free(sp-&gt;shared_ifc_set);
-		shm_free(sp);
 	}
 	return 0;
 }
@@ -485,7 +485,7 @@
 {
 	int i;
 	if (!bin_encode_str(x,&amp;(s-&gt;private_identity))) goto error;
-	if (!bin_encode_int2(x,s-&gt;service_profiles_cnt)) goto error;
+	if (!bin_encode_ushort(x,s-&gt;service_profiles_cnt)) goto error;
 
 	for(i=0;i&lt;s-&gt;service_profiles_cnt;i++)
 		if (!bin_encode_service_profile(x,s-&gt;service_profiles+i)) goto error;
@@ -516,7 +516,7 @@
 	memset(imss,0,sizeof(ims_subscription));
 	
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(imss-&gt;private_identity),&amp;s)) goto error;
-	if (!bin_decode_int2(x,	&amp;(imss-&gt;service_profiles_cnt))) goto error;
+	if (!bin_decode_ushort(x,	&amp;(imss-&gt;service_profiles_cnt))) goto error;
 	
 	len = sizeof(ims_service_profile)*imss-&gt;service_profiles_cnt;
 	imss-&gt;service_profiles = (ims_service_profile*)shm_malloc(len);
@@ -557,7 +557,7 @@
 int bin_encode_r_contact(bin_data *x,r_contact *c)
 {
 	if (!bin_encode_str(x,&amp;(c-&gt;uri))) goto error;
-	if (!bin_encode_int4(x,c-&gt;expires)) goto error;
+	if (!bin_encode_time_t(x,c-&gt;expires)) goto error;
 	if (!bin_encode_str(x,&amp;(c-&gt;ua))) goto error;
 	if (!bin_encode_str(x,&amp;(c-&gt;path))) goto error;
 
@@ -575,7 +575,7 @@
 r_contact* bin_decode_r_contact(bin_data *x)
 {
 	r_contact *c=0;
-	int len,k;
+	int len;
 	str s;
 	
 	len = sizeof(r_contact);
@@ -587,8 +587,7 @@
 	memset(c,0,len);
 	
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(c-&gt;uri),&amp;s)) goto error;
-	if (!bin_decode_int4(x,&amp;(k))) goto error;
-	c-&gt;expires = k;
+	if (!bin_decode_time_t(x,&amp;c-&gt;expires)) goto error;
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(c-&gt;ua),&amp;s)) goto error;
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(c-&gt;path),&amp;s)) goto error;
 	
@@ -615,10 +614,10 @@
 int bin_encode_r_subscriber(bin_data *x,r_subscriber *s)
 {
 	if (!bin_encode_str(x,&amp;(s-&gt;subscriber))) goto error;
-	if (!bin_encode_int1(x,s-&gt;event)) goto error;
-	if (!bin_encode_int4(x,s-&gt;expires)) goto error;
+	if (!bin_encode_char(x,s-&gt;event)) goto error;
+	if (!bin_encode_time_t(x,s-&gt;expires)) goto error;
 	if (!bin_encode_dlg_t(x,s-&gt;dialog)) goto error;
-	if (!bin_encode_int4(x,s-&gt;version)) goto error;
+	if (!bin_encode_int(x,s-&gt;version)) goto error;
 
 	return 1;
 error:
@@ -646,16 +645,17 @@
 	memset(s,0,len);
 	
 	if (!bin_decode_str(x,&amp;st)||!str_shm_dup(&amp;(s-&gt;subscriber),&amp;st)) goto error;
-	if (!bin_decode_int1(x,&amp;(s-&gt;event))) goto error;
-	if (!bin_decode_int4(x,&amp;(s-&gt;expires))) goto error;
+	if (!bin_decode_char(x,&amp;(s-&gt;event))) goto error;
+	if (!bin_decode_time_t(x,&amp;(s-&gt;expires))) goto error;
 	if (!bin_decode_dlg_t(x,&amp;(s-&gt;dialog))) goto error;
-	if (!bin_decode_int4(x,&amp;(s-&gt;version))) goto error;	
+	if (!bin_decode_int(x,&amp;(s-&gt;version))) goto error;	
 	
 	return s;
 error:
 	LOG(L_ERR,&quot;ERR:&quot;M_NAME&quot;:bin_decode_r_contact: Error while decoding (at %d (%04x)).\n&quot;,x-&gt;max,x-&gt;max);
 	if (s) {
 		if (s-&gt;subscriber.s) shm_free(s-&gt;subscriber.s);
+		if (s-&gt;dialog) tmb.free_dlg(s-&gt;dialog);
 		shm_free(s);
 	}
 	return 0;
@@ -671,30 +671,30 @@
  */
 int bin_encode_r_public(bin_data *x,r_public *p)
 {
-	int k;
+	unsigned short k;
+	char ch;
 	r_contact *c=0;
 	r_subscriber *s=0;
 	
 	if (!bin_encode_str(x,&amp;(p-&gt;aor))) goto error;
-	k = p-&gt;reg_state;
-	if (!bin_encode_int1(x,k)) goto error;
+	ch = p-&gt;reg_state;
+	if (!bin_encode_char(x,ch)) goto error;
 	if (!bin_encode_ims_subscription(x,p-&gt;s)) goto error;
 	
 	k=0;
 	for(c=p-&gt;head;c;c=c-&gt;next)
 		k++;
-	if (!bin_encode_int2(x,k)) goto error;
+	if (!bin_encode_ushort(x,k)) goto error;
 	for(c=p-&gt;head;c;c=c-&gt;next)
 		if (!bin_encode_r_contact(x,c)) goto error;	
 	
 	k=0;
 	for(s=p-&gt;shead;s;s=s-&gt;next)
 		k++;
-	if (!bin_encode_int2(x,k)) goto error;
+	if (!bin_encode_ushort(x,k)) goto error;
 	for(s=p-&gt;shead;s;s=s-&gt;next)
 		if (!bin_encode_r_subscriber(x,s)) goto error;	
 	
-
 	return 1;
 error:
 	LOG(L_ERR,&quot;ERR:&quot;M_NAME&quot;:bin_encode_r_public: Error while encoding.\n&quot;);
@@ -711,7 +711,9 @@
 	r_public *p=0;
 	r_contact *c=0,*cn=0;
 	r_subscriber *s,*sn=0;
-	int len,k,i;
+	int len,i;
+	unsigned short k;
+	char ch;
 	str st;
 	
 	len = sizeof(r_public);
@@ -724,13 +726,13 @@
 	
 	if (!bin_decode_str(x,&amp;st)||!str_shm_dup(&amp;(p-&gt;aor),&amp;st)) goto error;
 	p-&gt;hash = get_aor_hash(p-&gt;aor,r_hash_size);
-	if (!bin_decode_int1(x,&amp;k)) goto error;
-	p-&gt;reg_state = k;
+	if (!bin_decode_char(x,&amp;ch)) goto error;
+	p-&gt;reg_state = ch;
 	
 	p-&gt;s = bin_decode_ims_subscription(x);
 	if (!p-&gt;s) goto error;
 	
-	if (!bin_decode_int2(x,&amp;k)) goto error;
+	if (!bin_decode_ushort(x,&amp;k)) goto error;
 	for(i=0;i&lt;k;i++){
 		c = bin_decode_r_contact(x);
 		if (!c) goto error;
@@ -741,7 +743,7 @@
 		p-&gt;tail = c;
 	}
 
-	if (!bin_decode_int2(x,&amp;k)) goto error;
+	if (!bin_decode_ushort(x,&amp;k)) goto error;
 	for(i=0;i&lt;k;i++){
 		s = bin_decode_r_subscriber(x);
 		if (!s) goto error;
@@ -789,16 +791,16 @@
  */
  int bin_encode_auth_vector(bin_data *x,auth_vector *v)
 {
-	int k;
-	if (!bin_encode_int4(x,v-&gt;item_number)) goto error;
+	char ch;
+	if (!bin_encode_int(x,v-&gt;item_number)) goto error;
 	if (!bin_encode_str(x,&amp;(v-&gt;algorithm))) goto error;
 	if (!bin_encode_str(x,&amp;(v-&gt;authenticate))) goto error;
 	if (!bin_encode_str(x,&amp;(v-&gt;authorization))) goto error;
 	if (!bin_encode_str(x,&amp;(v-&gt;ck))) goto error;
 	if (!bin_encode_str(x,&amp;(v-&gt;ik))) goto error;
-	if (!bin_encode_int4(x,v-&gt;expires)) goto error;
-	k = v-&gt;status;
-	if (!bin_encode_int1(x,k)) goto error;
+	if (!bin_encode_time_t(x,v-&gt;expires)) goto error;
+	ch = v-&gt;status;
+	if (!bin_encode_char(x,ch)) goto error;
 
 	return 1;
 error:
@@ -814,7 +816,8 @@
 auth_vector* bin_decode_auth_vector(bin_data *x)
 {
 	auth_vector *v=0;
-	int len,k;
+	int len;
+	char ch;
 	str s;
 	
 	len = sizeof(auth_vector);
@@ -825,16 +828,16 @@
 	}
 	memset(v,0,len);
 	
-	if (!bin_decode_int4(x,&amp;(v-&gt;item_number))) goto error;
+	if (!bin_decode_int(x,&amp;(v-&gt;item_number))) goto error;
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(v-&gt;algorithm),&amp;s)) goto error;
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(v-&gt;authenticate),&amp;s)) goto error;
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(v-&gt;authorization),&amp;s)) goto error;
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(v-&gt;ck),&amp;s)) goto error;
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(v-&gt;ik),&amp;s)) goto error;
 
-	if (!bin_decode_int4(x,	&amp;(v-&gt;expires))) goto error;
-	if (!bin_decode_int1(x,	&amp;k)) goto error;
-	v-&gt;status=k;
+	if (!bin_decode_time_t(x,	&amp;(v-&gt;expires))) goto error;
+	if (!bin_decode_char(x,	&amp;ch)) goto error;
+	v-&gt;status=ch;
 	
 	return v;
 error:
@@ -862,18 +865,17 @@
  */
  int bin_encode_auth_userdata(bin_data *x,auth_userdata *u)
 {
-	int k=0;
+	unsigned short k=0;
 	auth_vector *v;
 	
 	if (!bin_encode_str(x,&amp;(u-&gt;private_identity))) goto error;
 	if (!bin_encode_str(x,&amp;(u-&gt;public_identity))) goto error;
-//	if (!bin_encode_int4(x,u-&gt;hash)) goto error;
-	if (!bin_encode_int4(x,u-&gt;expires)) goto error;
+	if (!bin_encode_time_t(x,u-&gt;expires)) goto error;
 	
 	for(v=u-&gt;head;v;v=v-&gt;next)
 		k++;
 
-	if (!bin_encode_int2(x,k)) goto error;
+	if (!bin_encode_ushort(x,k)) goto error;
 	for(v=u-&gt;head;v;v=v-&gt;next)
 		if (!bin_encode_auth_vector(x,v)) goto error;
 
@@ -892,7 +894,8 @@
 {
 	auth_userdata *u=0;
 	auth_vector *v=0,*vn=0;
-	int i,len,k;
+	int i,len;
+	unsigned short k;
 	str s;
 	
 	len = sizeof(auth_userdata);
@@ -906,10 +909,9 @@
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(u-&gt;private_identity),&amp;s)) goto error;
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(u-&gt;public_identity),&amp;s)) goto error;
 	u-&gt;hash = get_hash_auth(u-&gt;private_identity,u-&gt;public_identity);	
-//	if (!bin_decode_int4(x,	&amp;(u-&gt;hash))) goto error;
-	if (!bin_decode_int4(x,	&amp;(u-&gt;expires))) goto error;
+	if (!bin_decode_time_t(x,	&amp;(u-&gt;expires))) goto error;
 	
-	if (!bin_decode_int2(x,	&amp;k)) goto error;
+	if (!bin_decode_ushort(x,	&amp;k)) goto error;
 	
 	for(i=0;i&lt;k;i++){
 		v = bin_decode_auth_vector(x);
@@ -958,21 +960,24 @@
  */
 int bin_encode_s_dialog(bin_data *x,s_dialog *d)
 {
-//	if (!bin_encode_int4(x,d-&gt;hash)) goto error;	
+	char ch;
 	if (!bin_encode_str(x,&amp;(d-&gt;call_id))) goto error;
-	if (!bin_encode_int1(x,d-&gt;direction)) goto error;
+	ch = d-&gt;direction;
+	if (!bin_encode_char(x,ch)) goto error;
 	
 	if (!bin_encode_str(x,&amp;(d-&gt;aor))) goto error;
 	
-	if (!bin_encode_int1(x,d-&gt;method)) goto error;	
+	ch = d-&gt;method;
+	if (!bin_encode_char(x,ch)) goto error;	
 	if (!bin_encode_str(x,&amp;(d-&gt;method_str))) goto error;
 	
-	if (!bin_encode_int4(x,d-&gt;first_cseq)) goto error;	
-	if (!bin_encode_int4(x,d-&gt;last_cseq)) goto error;	
+	if (!bin_encode_int(x,d-&gt;first_cseq)) goto error;	
+	if (!bin_encode_int(x,d-&gt;last_cseq)) goto error;	
 
-	if (!bin_encode_int1(x,d-&gt;state)) goto error;	
+	ch = d-&gt;state;
+	if (!bin_encode_char(x,ch)) goto error;	
 
-	if (!bin_encode_int4(x,d-&gt;expires)) goto error;	
+	if (!bin_encode_time_t(x,d-&gt;expires)) goto error;	
 	
 	return 1;
 error:
@@ -988,8 +993,9 @@
 s_dialog* bin_decode_s_dialog(bin_data *x)
 {
 	s_dialog *d=0;
-	int len,k;
+	int len;
 	str s;
+	char ch;
 	
 	len = sizeof(s_dialog);
 	d = (s_dialog*) shm_malloc(len);
@@ -999,28 +1005,24 @@
 	}
 	memset(d,0,len);
 
-//	if (!bin_decode_int4(x,	&amp;(d-&gt;hash))) goto error;		
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(d-&gt;call_id),&amp;s)) goto error;
 
-	if (!bin_decode_int1(x,	&amp;k)) goto error;
-	d-&gt;direction = k;
+	if (!bin_decode_char(x,	&amp;ch)) goto error;
+	d-&gt;direction = ch;
 	
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(d-&gt;aor),&amp;s)) goto error;
 		
-	if (!bin_decode_int1(x,	&amp;k)) goto error;
-	d-&gt;method = k;
+	if (!bin_decode_char(x,	&amp;ch)) goto error;
+	d-&gt;method = ch;
 	if (!bin_decode_str(x,&amp;s)||!str_shm_dup(&amp;(d-&gt;method_str),&amp;s)) goto error;
 	
-	if (!bin_decode_int4(x,	&amp;k)) goto error;
-	d-&gt;first_cseq = k;
-	if (!bin_decode_int4(x,	&amp;k)) goto error;
-	d-&gt;last_cseq = k;
+	if (!bin_decode_int(x,	&amp;d-&gt;first_cseq)) goto error;
+	if (!bin_decode_int(x,	&amp;d-&gt;last_cseq)) goto error;
 
-	if (!bin_decode_int1(x,	&amp;k)) goto error;
-	d-&gt;state = k;
+	if (!bin_decode_char(x,	&amp;ch)) goto error;
+	d-&gt;state = ch;
 	
-	if (!bin_decode_int4(x,	&amp;k)) goto error;
-	d-&gt;expires = k;
+	if (!bin_decode_time_t(x, &amp;d-&gt;expires)) goto error;
 	
 	d-&gt;hash = get_s_dialog_hash(d-&gt;call_id);		
 	

Modified: ser_ims/branches/01_persistency/modules/scscf/bin_scscf.h
===================================================================
--- ser_ims/branches/01_persistency/modules/scscf/bin_scscf.h	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/scscf/bin_scscf.h	2007-02-08 00:14:53 UTC (rev 128)
@@ -62,6 +62,7 @@
 #include &quot;registration.h&quot;
 #include &quot;registrar_storage.h&quot;
 #include &quot;dlg_state.h&quot;
+#include &quot;../tm/tm_load.h&quot;
 
 
 #define BIN_INITIAL_ALLOC_SIZE 256

Modified: ser_ims/branches/01_persistency/modules/scscf/ifc_datastruct.h
===================================================================
--- ser_ims/branches/01_persistency/modules/scscf/ifc_datastruct.h	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/scscf/ifc_datastruct.h	2007-02-08 00:14:53 UTC (rev 128)
@@ -66,7 +66,7 @@
 {
 	str header;				/**&lt; name of the header to match	*/
 	str content;			/**&lt; regex to match             	*/
-	int type;				/**&lt; if known header, precalculated	*/
+	short type;				/**&lt; if known header, precalculated	*/
 } ims_sip_header;
 
 
@@ -107,18 +107,18 @@
 /** Service Point Trigger Structure */
 typedef struct _ims_spt
 {
-	int condition_negated;				/**&lt; if to negate entire condition	*/
+	char condition_negated;				/**&lt; if to negate entire condition	*/
 	int group;			 			  	/**&lt; group to which it belongs		*/
-	int type;							/**&lt; type of condition				*/
+	char type;							/**&lt; type of condition				*/
 	union
 	{
 		str request_uri;				/**&lt; Request URI regex				*/
 		str method;						/**&lt; the SIP method should be this	*/
 		ims_sip_header sip_header;		/**&lt; match of a certain SIP header	*/
-		int session_case;				/**&lt; session direction and case		*/
+		char session_case;				/**&lt; session direction and case		*/
 		ims_session_desc session_desc;	/**&lt; session description match 		*/
 	};									/**&lt; union for SPT 					*/
-	int registration_type;				/**&lt; set of registration types		*/
+	char registration_type;				/**&lt; set of registration types		*/
 } ims_spt;
 
 /** Conjunctive Normal Format */
@@ -129,9 +129,9 @@
 /** Trigger Point Structure */
 typedef struct _ims_trigger_point
 {
-	int condition_type_cnf;	/**&lt; if it's CNF or DNF     		*/
+	char condition_type_cnf;	/**&lt; if it's CNF or DNF     		*/
 	ims_spt *spt;			/**&lt; service point triggers 1..n 		*/
-	int spt_cnt;			/**&lt; number of service point triggers 	*/
+	unsigned short spt_cnt;			/**&lt; number of service point triggers 	*/
 } ims_trigger_point;
 
 /** No default handling */
@@ -145,13 +145,13 @@
 typedef struct _ims_application_server
 {
 	str server_name;			/**&lt; SIP URL of the app server                      */
-	int default_handling;		/**&lt; enum SESSION_CONTINUED SESSION_TERMINATED 0..1 */
+	char default_handling;		/**&lt; enum SESSION_CONTINUED SESSION_TERMINATED 0..1 */
 	str service_info;			/**&lt; optional info to be sent to AS 0..1            */
 } ims_application_server;
 
 /** Public Identity Structure */
 typedef struct {
-	int barring;				/**&lt; Barring state									*/
+	char barring;				/**&lt; Barring state									*/
 	str public_identity;		/**&lt; Public Identity string							*/
 } ims_public_identity;
 
@@ -161,7 +161,7 @@
 	int priority;								/**&lt; checking priority, lower means more important */
 	ims_trigger_point *trigger_point;			/**&lt; definition of trigger 0..1 */
 	ims_application_server application_server;	/**&lt; target of the trigger   */
-	int *profile_part_indicator;				/**&lt; profile part indicator 0..1 */	
+	char *profile_part_indicator;				/**&lt; profile part indicator 0..1 */	
 } ims_filter_criteria;
 
 /** CoreNetwork Service Authorization */
@@ -173,22 +173,22 @@
 /** Service Profile Structure */
 typedef struct {
 	ims_public_identity *public_identities;	/**&lt; array of public identities		*/
-	int public_identities_cnt;				/**&lt; number of public identities	*/
+	unsigned short public_identities_cnt;				/**&lt; number of public identities	*/
 
 	ims_filter_criteria *filter_criteria;	/**&lt; vector of filter criteria 0..n */
-	int filter_criteria_cnt;				/**&lt; size of the vector above		*/
+	unsigned short filter_criteria_cnt;				/**&lt; size of the vector above		*/
 
 	ims_cn_service_auth *cn_service_auth;	/**&lt; core net. services auth. 0..1	*/
 
 	int *shared_ifc_set;					/**&lt; shared ifc set ids 0..n 		*/
-	int shared_ifc_set_cnt;					/**&lt; size of above vector 			*/	
+	unsigned short shared_ifc_set_cnt;					/**&lt; size of above vector 			*/	
 } ims_service_profile;
 
 /** User Subscription Structure */ 
 typedef struct {	
 	str private_identity;					/**&lt; private identity 				*/
 	ims_service_profile *service_profiles;	/**&lt; array of service profiles		*/
-	int service_profiles_cnt;				/**&lt; size of the array above		*/
+	unsigned short service_profiles_cnt;				/**&lt; size of the array above		*/
 		
 	int ref_count;							/**&lt; referenced count 				*/
 	gen_lock_t *lock;						/**&lt; lock for operations on it 		*/

Modified: ser_ims/branches/01_persistency/modules/scscf/registrar_parser.c
===================================================================
--- ser_ims/branches/01_persistency/modules/scscf/registrar_parser.c	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/scscf/registrar_parser.c	2007-02-08 00:14:53 UTC (rev 128)
@@ -201,7 +201,7 @@
  * @param x - input value
  * @returns int value
  */
-static inline int ifc_tBool2int(xmlChar *x)
+static inline char ifc_tBool2char(xmlChar *x)
 {
 	int r=0;	
 	while(x[r]){
@@ -223,9 +223,9 @@
  * @param x - input value
  * @returns int value
  */
-static inline int ifc_tDefaultHandling2int(xmlChar *x)
+static inline char ifc_tDefaultHandling2char(xmlChar *x)
 {
-	int r;	
+	char r;	
 	r = strtol(x, (char **)NULL, 10);
 	if (errno==EINVAL){
 		while(x[0]){
@@ -235,7 +235,7 @@
 		}
 		return 0;
 	} 
-	else return r; 
+	else return (char)r; 
 }
 
 /**
@@ -246,7 +246,7 @@
  * @param x - input value
  * @returns int value
  */
-static inline int ifc_tDirectionOfRequest2int(xmlChar *x)
+static inline char ifc_tDirectionOfRequest2char(xmlChar *x)
 {
 	int r;	
 	r = strtol(x, (char **)NULL, 10);
@@ -259,7 +259,7 @@
 		}
 		return 0;
 	} 
-	else return r; 
+	else return (char)r; 
 }
 
 /**
@@ -270,7 +270,7 @@
  * @param x - input value
  * @returns int value
  */
-static inline int ifc_tProfilePartIndicator2int(xmlChar *x)
+static inline char ifc_tProfilePartIndicator2char(xmlChar *x)
 {
 	int r;	
 	if (x==0||x[0]==0) return -1;
@@ -283,7 +283,7 @@
 		}
 		return 0;
 	} 
-	else return r; 
+	else return (char)r; 
 }
 
 
@@ -311,7 +311,7 @@
 					break;
 				case 'B': case 'b':
 					x = xmlNodeListGetString(doc,child-&gt;xmlChildrenNode,1);
-					pi-&gt;barring = ifc_tBool2int(x);
+					pi-&gt;barring = ifc_tBool2char(x);
 					xmlFree(x);
 					break;				
 			}
@@ -340,7 +340,7 @@
 					x = xmlNodeListGetString(doc, child-&gt;xmlChildrenNode, 1);
 					space_trim_dup(&amp;(sh-&gt;header),x);
 					parse_hname2(sh-&gt;header.s,sh-&gt;header.s+sh-&gt;header.len,&amp;hf);
-					sh-&gt;type=hf.type;
+					sh-&gt;type=(short)hf.type;
 					xmlFree(x);
 					break;
 				case 'C':case 'c':	//Content
@@ -391,7 +391,7 @@
  * @param spt_cnt - structure to fill with the spt count
  * @returns 1 on success, 0 on failure
  */
-static int parse_spt(xmlDocPtr doc,xmlNodePtr node,ims_spt *spt_to,int *spt_cnt)
+static int parse_spt(xmlDocPtr doc,xmlNodePtr node,ims_spt *spt_to,unsigned short *spt_cnt)
 {
 	xmlNodePtr child,saved=0;
 	xmlChar *x;
@@ -411,7 +411,7 @@
 			switch (child-&gt;name[0]) {
 				case 'C':case 'c': //ConditionNegated
 					x = xmlNodeListGetString(doc, child-&gt;xmlChildrenNode, 1);
-					spt-&gt;condition_negated=ifc_tBool2int(x);
+					spt-&gt;condition_negated=ifc_tBool2char(x);
 					xmlFree(x);
 					break;
 				case 'G':case 'g': //Group
@@ -461,7 +461,7 @@
 						case 'C':case 'c'://Session Case
 							spt-&gt;type=IFC_SESSION_CASE;
 							x = xmlNodeListGetString(doc, child-&gt;xmlChildrenNode, 1);
-							spt-&gt;session_case=ifc_tDirectionOfRequest2int(x);
+							spt-&gt;session_case=ifc_tDirectionOfRequest2char(x);
 							xmlFree(x);
 							break;
 						case 'D':case 'd'://Session Description
@@ -538,7 +538,8 @@
 {
 	xmlNodePtr child,child2;
 	xmlChar *x;
-	int spt_cnt=0,i,j;
+	unsigned short spt_cnt=0;
+	int i,j;
 	ims_spt spttemp;
 	tp-&gt;condition_type_cnf=IFC_DNF;//0
 	tp-&gt;spt=NULL;
@@ -549,7 +550,7 @@
 			switch (child-&gt;name[0]) {
 				case 'C':case 'c': //ConditionTypeCNF
 					x = xmlNodeListGetString(doc, child-&gt;xmlChildrenNode, 1);
-					tp-&gt;condition_type_cnf=ifc_tBool2int(x);
+					tp-&gt;condition_type_cnf=ifc_tBool2char(x);
 					xmlFree(x);
 					break;
 				case 'S':case 's': //SPT - Service Point Trigger
@@ -631,7 +632,7 @@
 				}
 				case 'D':case 'd': //DefaultHandling
 					x = xmlNodeListGetString(doc, child-&gt;xmlChildrenNode, 1);
-					as-&gt;default_handling=ifc_tDefaultHandling2int(x);
+					as-&gt;default_handling=ifc_tDefaultHandling2char(x);
 					xmlFree(x);
 					break;
 			}
@@ -651,7 +652,7 @@
 {
 	xmlNodePtr child;
 	xmlChar *x;
-	int k;
+	char k;
 	fc-&gt;priority=0;
 	fc-&gt;trigger_point=NULL;
 	fc-&gt;profile_part_indicator=NULL;
@@ -681,9 +682,9 @@
 					break;
 				case 'F':case 'f':	//ProfilePartIndicator
 					x = xmlNodeListGetString(doc, child-&gt;xmlChildrenNode, 1);
-					k = ifc_tProfilePartIndicator2int(x);
+					k = ifc_tProfilePartIndicator2char(x);
 					if (k&lt;0) break;
-					fc-&gt;profile_part_indicator=shm_malloc(sizeof(int));
+					fc-&gt;profile_part_indicator=(char*)shm_malloc(sizeof(char));
 					if (!fc-&gt;profile_part_indicator){
 						LOG(L_ERR,&quot;ERR:&quot;M_NAME&quot;:parse_filter_criteria: Out of memory allocating %d bytes\n&quot;,sizeof(ims_trigger_point));
 						break;
@@ -733,7 +734,8 @@
 {
 	xmlNodePtr child;
 	xmlChar *x;
-	int pi_cnt=0,ifc_cnt=0,sh_cnt=0,i,j;;
+	unsigned short pi_cnt=0,ifc_cnt=0,sh_cnt=0;
+	int i,j;
 	ims_filter_criteria fctemp;
 	
 	for(child=root-&gt;children;child;child=child-&gt;next)
@@ -820,7 +822,7 @@
 	xmlNodePtr child;
 	xmlChar *x;
 	ims_subscription *s;
-	int sp_cnt=0;
+	unsigned short sp_cnt=0;
 	
 	if (!root) return 0;
 	while(root-&gt;type!=XML_ELEMENT_NODE || strcasecmp(root-&gt;name,&quot;IMSSubscription&quot;)!=0){

Modified: ser_ims/branches/01_persistency/modules/scscf/registrar_storage.h
===================================================================
--- ser_ims/branches/01_persistency/modules/scscf/registrar_storage.h	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/scscf/registrar_storage.h	2007-02-08 00:14:53 UTC (rev 128)
@@ -78,9 +78,9 @@
 /** registrar subscriber structure */
 typedef struct _r_subscriber {
 	str subscriber;				/**&lt; The subscribers contact 			*/
-	int event;
+	char event;
 
-	int expires;				/**&lt; Time of expiration		 			*/
+	time_t expires;				/**&lt; Time of expiration		 			*/
 	dlg_t *dialog;				/**&lt; tm dialog to send notify out		*/
 	
 	int version;				/**&lt; Last version sent to this subs.	*/

Modified: ser_ims/branches/01_persistency/modules/scscf/registration.c
===================================================================
--- ser_ims/branches/01_persistency/modules/scscf/registration.c	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/scscf/registration.c	2007-02-08 00:14:53 UTC (rev 128)
@@ -1182,7 +1182,7 @@
 			av = aud-&gt;head;
 			while(av){
 				LOG(L_DBG,&quot;DBG:&quot;M_NAME&quot;:reg_await_timer: .. AV %4d - %d Exp %3d  %p\n&quot;,
-					av-&gt;item_number,av-&gt;status,av-&gt;expires,av);
+					av-&gt;item_number,av-&gt;status,(int)av-&gt;expires,av);
 				av_next = av-&gt;next;
 				if ((av-&gt;status == AUTH_VECTOR_USELESS || 
 					av-&gt;status == AUTH_VECTOR_SENT) &amp;&amp; av-&gt;expires&lt;ticks)

Modified: ser_ims/branches/01_persistency/modules/scscf/registration.h
===================================================================
--- ser_ims/branches/01_persistency/modules/scscf/registration.h	2007-02-07 21:20:14 UTC (rev 127)
+++ ser_ims/branches/01_persistency/modules/scscf/registration.h	2007-02-08 00:14:53 UTC (rev 128)
@@ -90,7 +90,7 @@
 	str authorization; 	/**&lt; expected response				*/
 	str ck;				/**&lt; Cypher Key						*/
 	str ik;				/**&lt; Integrity Key					*/
-	unsigned int expires;/**&lt; expires in (after it is sent)	*/
+	time_t expires;/**&lt; expires in (after it is sent)	*/
 	
 	enum auth_vector_status status;/**&lt; current status		*/
 	struct _auth_vector *next;/**&lt; next av in the list		*/
@@ -101,10 +101,10 @@
 
 /** Set of auth_vectors used by a private id */
 typedef struct _auth_userdata{
+	unsigned int hash;		/**&lt; hash of the auth data		*/
 	str private_identity;	/**&lt; authorization username		*/
 	str public_identity;	/**&lt; public identity linked to	*/
-	unsigned int hash;		/**&lt; hash of the auth data		*/
-	unsigned int expires;	/**&lt; expires in					*/
+	time_t expires;	/**&lt; expires in					*/
 	
 	auth_vector *head;		/**&lt; first auth vector in list	*/
 	auth_vector *tail;		/**&lt; last auth vector in list	*/


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000203.html">[OpenIMSCore-CSCF] changes to mysql when 127.0.0.1 is changed	to local IP
</A></li>
	<LI>Next message: <A HREF="000193.html">[OpenIMSCore-CSCF] [SVN-ser_ims] r129 - in	ser_ims/branches/01_persistency/modules: pcscf scscf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#191">[ date ]</a>
              <a href="thread.html#191">[ thread ]</a>
              <a href="subject.html#191">[ subject ]</a>
              <a href="author.html#191">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openimscore-cscf">More information about the OpenIMSCore-CSCF
mailing list</a><br>
</body></html>
